{"ast":null,"code":"import React, { Children, cloneElement, forwardRef, useContext, useState, useMemo, useLayoutEffect, useEffect, useRef, useReducer, useCallback, useImperativeHandle, memo } from 'react';\nimport ReactDOM, { unstable_batchedUpdates, createPortal } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { useTransition } from 'react-transition-state';\nconst menuContainerClass = 'szh-menu-container';\nconst menuClass = 'szh-menu';\nconst menuButtonClass = 'szh-menu-button';\nconst menuArrowClass = 'arrow';\nconst menuItemClass = 'item';\nconst menuDividerClass = 'divider';\nconst menuHeaderClass = 'header';\nconst menuGroupClass = 'group';\nconst subMenuClass = 'submenu';\nconst radioGroupClass = 'radio-group';\nconst initialHoverIndex = -1;\nconst HoverIndexContext = /*#__PURE__*/React.createContext(initialHoverIndex);\nconst MenuListItemContext = /*#__PURE__*/React.createContext({});\nconst MenuListContext = /*#__PURE__*/React.createContext({});\nconst EventHandlersContext = /*#__PURE__*/React.createContext({});\nconst RadioGroupContext = /*#__PURE__*/React.createContext({});\nconst SettingsContext = /*#__PURE__*/React.createContext({});\nconst ItemSettingsContext = /*#__PURE__*/React.createContext({});\nconst Keys = Object.freeze({\n  'ENTER': 'Enter',\n  'ESC': 'Escape',\n  'SPACE': ' ',\n  'HOME': 'Home',\n  'END': 'End',\n  'LEFT': 'ArrowLeft',\n  'RIGHT': 'ArrowRight',\n  'UP': 'ArrowUp',\n  'DOWN': 'ArrowDown'\n});\nconst HoverIndexActionTypes = Object.freeze({\n  'RESET': 'HOVER_RESET',\n  'SET': 'HOVER_SET',\n  'UNSET': 'HOVER_UNSET',\n  'INCREASE': 'HOVER_INCREASE',\n  'DECREASE': 'HOVER_DECREASE',\n  'FIRST': 'HOVER_FIRST',\n  'LAST': 'HOVER_LAST'\n});\nconst SubmenuActionTypes = Object.freeze({\n  'OPEN': 'SUBMENU_OPEN',\n  'CLOSE': 'SUBMENU_CLOSE'\n});\nconst CloseReason = Object.freeze({\n  'CLICK': 'click',\n  'CANCEL': 'cancel',\n  'BLUR': 'blur',\n  'SCROLL': 'scroll'\n});\nconst FocusPositions = Object.freeze({\n  'INITIAL': 'initial',\n  'FIRST': 'first',\n  'LAST': 'last'\n});\nconst MenuStateMap = Object.freeze({\n  entering: 'opening',\n  entered: 'open',\n  exiting: 'closing',\n  exited: 'closed'\n});\nconst isProd = process.env.NODE_ENV === 'production';\n\nconst isMenuOpen = state => !!state && state[0] === 'o';\n\nconst batchedUpdates = unstable_batchedUpdates || (callback => callback());\n\nconst values = Object.values || (obj => Object.keys(obj).map(key => obj[key]));\n\nconst floatEqual = (a, b, diff = 0.0001) => Math.abs(a - b) < diff;\n\nconst getTransition = (transition, name) => !!(transition && transition[name]) || transition === true;\n\nconst safeCall = (fn, ...args) => typeof fn === 'function' ? fn(...args) : fn;\n\nconst getName = component => component && component['_szhsinMenu'];\n\nconst defineName = (component, name) => name ? Object.defineProperty(component, '_szhsinMenu', {\n  value: name,\n  writable: false\n}) : component;\n\nconst applyHOC = HOC => (...args) => defineName(HOC(...args), getName(args[0]));\n\nconst applyStatics = sourceComponent => wrappedComponent => defineName(wrappedComponent, getName(sourceComponent));\n\nconst attachHandlerProps = (handlers, props) => {\n  if (!props) return handlers;\n  const result = {};\n\n  for (const handlerName of Object.keys(handlers)) {\n    const handler = handlers[handlerName];\n    const propHandler = props[handlerName];\n    let attachedHandler;\n\n    if (typeof propHandler === 'function') {\n      attachedHandler = e => {\n        propHandler(e);\n        handler(e);\n      };\n    } else {\n      attachedHandler = handler;\n    }\n\n    result[handlerName] = attachedHandler;\n  }\n\n  return result;\n};\n\nconst parsePadding = paddingStr => {\n  if (typeof paddingStr !== 'string') return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  const padding = paddingStr.trim().split(/\\s+/, 4).map(parseFloat);\n  const top = !isNaN(padding[0]) ? padding[0] : 0;\n  const right = !isNaN(padding[1]) ? padding[1] : top;\n  return {\n    top,\n    right,\n    bottom: !isNaN(padding[2]) ? padding[2] : top,\n    left: !isNaN(padding[3]) ? padding[3] : right\n  };\n};\n\nconst getScrollAncestor = node => {\n  while (node && node !== document.body) {\n    const {\n      overflow,\n      overflowX,\n      overflowY\n    } = getComputedStyle(node);\n    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) return node;\n    node = node.parentNode;\n  }\n\n  return window;\n};\n\nconst validateIndex = (index, isDisabled, node) => {\n  if (!isProd && index === undefined && !isDisabled) {\n    const error = `[React-Menu] Validate item '${node && node.toString()}' failed.\nYou're probably creating wrapping components or HOC over MenuItem, SubMenu or FocusableItem.\nTo create wrapping components, see: https://codesandbox.io/s/react-menu-wrapping-q0b59\nTo create HOCs, see: https://codesandbox.io/s/react-menu-hoc-0bipn`;\n    throw new Error(error);\n  }\n};\n\nconst cloneChildren = (children, startIndex = 0, inRadioGroup) => {\n  let index = startIndex;\n  let descendOverflow = false;\n  const items = Children.map(children, child => {\n    if (child === undefined || child === null) return null;\n    if (!child.type) return child;\n    const name = getName(child.type);\n\n    switch (name) {\n      case 'MenuItem':\n        {\n          if (inRadioGroup) {\n            const props = {\n              type: 'radio'\n            };\n            if (!child.props.disabled) props.index = index++;\n            return /*#__PURE__*/cloneElement(child, props);\n          }\n        }\n\n      case 'SubMenu':\n      case 'FocusableItem':\n        return child.props.disabled ? child : /*#__PURE__*/cloneElement(child, {\n          index: index++\n        });\n\n      default:\n        {\n          const innerChildren = child.props.children;\n          if (innerChildren === null || typeof innerChildren !== \"object\") return child;\n          const desc = cloneChildren(innerChildren, index, inRadioGroup || name === 'MenuRadioGroup');\n          index = desc.index;\n\n          if (name === 'MenuGroup') {\n            const takeOverflow = !!child.props.takeOverflow;\n            const descOverflow = desc.descendOverflow;\n            if (!isProd && (descendOverflow === descOverflow ? descOverflow : takeOverflow)) throw new Error('[React-Menu] Only one MenuGroup in a menu is allowed to have takeOverflow prop.');\n            descendOverflow = descendOverflow || descOverflow || takeOverflow;\n          }\n\n          return /*#__PURE__*/cloneElement(child, {\n            children: desc.items\n          });\n        }\n    }\n  });\n  return {\n    items,\n    index,\n    descendOverflow\n  };\n};\n\nconst stylePropTypes = name => ({\n  [name ? `${name}ClassName` : 'className']: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  [name ? `${name}Styles` : 'styles']: PropTypes.oneOfType([PropTypes.object, PropTypes.func])\n});\n\nconst menuPropTypes = {\n  className: PropTypes.string,\n  ...stylePropTypes('menu'),\n  ...stylePropTypes('arrow'),\n  arrow: PropTypes.bool,\n  offsetX: PropTypes.number,\n  offsetY: PropTypes.number,\n  align: PropTypes.oneOf(['start', 'center', 'end']),\n  direction: PropTypes.oneOf(['left', 'right', 'top', 'bottom']),\n  position: PropTypes.oneOf(['auto', 'anchor', 'initial']),\n  overflow: PropTypes.oneOf(['auto', 'visible', 'hidden'])\n};\nconst rootMenuPropTypes = { ...menuPropTypes,\n  containerProps: PropTypes.object,\n  initialMounted: PropTypes.bool,\n  unmountOnClose: PropTypes.bool,\n  transition: PropTypes.oneOfType([PropTypes.bool, PropTypes.exact({\n    open: PropTypes.bool,\n    close: PropTypes.bool,\n    item: PropTypes.bool\n  })]),\n  transitionTimeout: PropTypes.number,\n  boundingBoxRef: PropTypes.object,\n  boundingBoxPadding: PropTypes.string,\n  reposition: PropTypes.oneOf(['auto', 'initial']),\n  repositionFlag: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  viewScroll: PropTypes.oneOf(['auto', 'close', 'initial']),\n  submenuOpenDelay: PropTypes.number,\n  submenuCloseDelay: PropTypes.number,\n  portal: PropTypes.bool,\n  theming: PropTypes.string,\n  onItemClick: PropTypes.func\n};\nconst uncontrolledMenuPropTypes = {\n  instanceRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n  onMenuChange: PropTypes.func\n};\nconst menuDefaultProps = {\n  offsetX: 0,\n  offsetY: 0,\n  align: 'start',\n  direction: 'bottom',\n  position: 'auto',\n  overflow: 'visible'\n};\nconst rootMenuDefaultProps = { ...menuDefaultProps,\n  reposition: 'auto',\n  viewScroll: 'initial',\n  transitionTimeout: 200,\n  submenuOpenDelay: 300,\n  submenuCloseDelay: 150\n};\n\nconst withHovering = (WrapppedComponent, name) => {\n  const WithHovering = defineName( /*#__PURE__*/forwardRef((props, ref) => {\n    return /*#__PURE__*/React.createElement(WrapppedComponent, Object.assign({}, props, {\n      externalRef: ref,\n      isHovering: useContext(HoverIndexContext) === props.index\n    }));\n  }), name);\n  WithHovering.displayName = `WithHovering(${name})`;\n  return WithHovering;\n};\n\nconst useActiveState = (isHovering, isDisabled, ...moreKeys) => {\n  const [active, setActive] = useState(false);\n  const activeKeys = [Keys.ENTER, Keys.SPACE, ...moreKeys];\n\n  const cancelActive = () => active && setActive(false);\n\n  return {\n    isActive: active,\n    onPointerDown: () => {\n      if (!isDisabled) setActive(true);\n    },\n    onPointerUp: cancelActive,\n    onPointerLeave: cancelActive,\n    onKeyDown: e => {\n      if (!active && isHovering && !isDisabled && activeKeys.indexOf(e.key) !== -1) {\n        setActive(true);\n      }\n    },\n    onKeyUp: e => {\n      if (activeKeys.indexOf(e.key) !== -1) {\n        setActive(false);\n      }\n    },\n    onBlur: e => {\n      if (active && !e.currentTarget.contains(e.relatedTarget)) {\n        setActive(false);\n      }\n    }\n  };\n};\n\nconst useBEM = ({\n  block,\n  element,\n  modifiers,\n  className\n}) => useMemo(() => {\n  const blockElement = element ? `${block}__${element}` : block;\n  let classString = blockElement;\n\n  for (const name of Object.keys(modifiers || {})) {\n    const value = modifiers[name];\n\n    if (value) {\n      classString += ` ${blockElement}--`;\n      classString += value === true ? name : `${name}-${value}`;\n    }\n  }\n\n  let expandedClassName = typeof className === 'function' ? className(modifiers) : className;\n\n  if (typeof expandedClassName === 'string') {\n    expandedClassName = expandedClassName.trim();\n    if (expandedClassName) classString += ` ${expandedClassName}`;\n  }\n\n  return classString;\n}, [block, element, modifiers, className]);\n\nconst setRef = (ref, element) => {\n  if (typeof ref === 'function') {\n    ref(element);\n  } else if (ref) {\n    ref.current = element;\n  }\n};\n\nconst useCombinedRef = (refA, refB) => useMemo(() => {\n  if (!refA) return refB;\n  if (!refB) return refA;\n  return element => {\n    setRef(refA, element);\n    setRef(refB, element);\n  };\n}, [refA, refB]);\n\nconst isObject = obj => obj && typeof obj === 'object';\n\nconst sanitiseKey = key => key[0] === '$' ? key.slice(1) : key;\n\nconst useFlatStyles = (styles, modifiers) => useMemo(() => {\n  if (typeof styles === 'function') return styles(modifiers);\n  if (!isObject(styles)) return undefined;\n  if (!modifiers) return styles;\n  const style = {};\n\n  for (const prop of Object.keys(styles)) {\n    const value = styles[prop];\n\n    if (isObject(value)) {\n      const modifierValue = modifiers[sanitiseKey(prop)];\n\n      if (typeof modifierValue === 'string') {\n        for (const nestedProp of Object.keys(value)) {\n          const nestedValue = value[nestedProp];\n\n          if (isObject(nestedValue)) {\n            if (sanitiseKey(nestedProp) === modifierValue) {\n              Object.assign(style, nestedValue);\n            }\n          } else {\n            style[nestedProp] = nestedValue;\n          }\n        }\n      } else if (modifierValue) {\n        Object.assign(style, value);\n      }\n    } else {\n      style[prop] = value;\n    }\n  }\n\n  return style;\n}, [styles, modifiers]);\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nconst useItemState = (ref, index, isHovering, isDisabled) => {\n  const {\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const timeoutId = useRef();\n\n  const setHover = () => {\n    if (!isDisabled) dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n  };\n\n  const onBlur = e => {\n    if (isHovering && !e.currentTarget.contains(e.relatedTarget)) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const onMouseEnter = () => {\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(setHover, submenuCloseDelay);\n    } else {\n      setHover();\n    }\n  };\n\n  const onMouseLeave = (_, keepHover) => {\n    timeoutId.current && clearTimeout(timeoutId.current);\n    if (!keepHover) dispatch({\n      type: HoverIndexActionTypes.UNSET,\n      index\n    });\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      ref.current && ref.current.focus();\n    }\n  }, [ref, isHovering, isParentOpen]);\n  return {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  };\n};\n\nconst useMenuChange = (onMenuChange, isOpen) => {\n  const prevOpen = useRef(isOpen);\n  useEffect(() => {\n    if (prevOpen.current !== isOpen) safeCall(onMenuChange, {\n      open: isOpen\n    });\n    prevOpen.current = isOpen;\n  }, [onMenuChange, isOpen]);\n};\n\nconst useMenuState = ({\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout\n} = {}) => {\n  const [state, toggleMenu, endTransition] = useTransition({\n    mountOnEnter: !initialMounted,\n    unmountOnExit: unmountOnClose,\n    timeout: transitionTimeout,\n    enter: getTransition(transition, 'open'),\n    exit: getTransition(transition, 'close')\n  });\n  return {\n    state: MenuStateMap[state],\n    toggleMenu,\n    endTransition\n  };\n};\n\nconst useMenuStateAndFocus = options => {\n  const menuState = useMenuState(options);\n  const [menuItemFocus, setMenuItemFocus] = useState({});\n\n  const openMenu = (position, alwaysUpdate) => {\n    setMenuItemFocus({\n      position,\n      alwaysUpdate\n    });\n    menuState.toggleMenu(true);\n  };\n\n  return { ...menuState,\n    openMenu,\n    menuItemFocus\n  };\n};\n\nconst MenuButton = defineName( /*#__PURE__*/forwardRef(function MenuButton({\n  className,\n  styles,\n  isOpen,\n  disabled,\n  children,\n  ...restProps\n}, ref) {\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen\n  }), [isOpen]);\n  return /*#__PURE__*/React.createElement(\"button\", Object.assign({\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": disabled || undefined,\n    type: \"button\",\n    disabled: disabled\n  }, restProps, {\n    ref: ref,\n    className: useBEM({\n      block: menuButtonClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), children);\n}), 'MenuButton');\nMenuButton.propTypes = { ...stylePropTypes(),\n  isOpen: PropTypes.bool,\n  disabled: PropTypes.bool\n};\n\nconst getPositionHelpers = ({\n  menuRef,\n  containerRef,\n  scrollingRef,\n  boundingBoxPadding\n}) => {\n  const menuRect = menuRef.current.getBoundingClientRect();\n  const containerRect = containerRef.current.getBoundingClientRect();\n  const boundingRect = scrollingRef.current === window ? {\n    left: 0,\n    top: 0,\n    right: document.documentElement.clientWidth,\n    bottom: window.innerHeight\n  } : scrollingRef.current.getBoundingClientRect();\n  const padding = parsePadding(boundingBoxPadding);\n\n  const getLeftOverflow = x => x + containerRect.left - boundingRect.left - padding.left;\n\n  const getRightOverflow = x => x + containerRect.left + menuRect.width - boundingRect.right + padding.right;\n\n  const getTopOverflow = y => y + containerRect.top - boundingRect.top - padding.top;\n\n  const getBottomOverflow = y => y + containerRect.top + menuRect.height - boundingRect.bottom + padding.bottom;\n\n  const confineHorizontally = x => {\n    let leftOverflow = getLeftOverflow(x);\n\n    if (leftOverflow < 0) {\n      x -= leftOverflow;\n    } else {\n      const rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        x -= rightOverflow;\n        leftOverflow = getLeftOverflow(x);\n        if (leftOverflow < 0) x -= leftOverflow;\n      }\n    }\n\n    return x;\n  };\n\n  const confineVertically = y => {\n    let topOverflow = getTopOverflow(y);\n\n    if (topOverflow < 0) {\n      y -= topOverflow;\n    } else {\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        y -= bottomOverflow;\n        topOverflow = getTopOverflow(y);\n        if (topOverflow < 0) y -= topOverflow;\n      }\n    }\n\n    return y;\n  };\n\n  return {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  };\n};\n\nconst positionContextMenu = ({\n  positionHelpers,\n  anchorPoint\n}) => {\n  const {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  } = positionHelpers;\n  let x, y;\n  x = anchorPoint.x - containerRect.left;\n  y = anchorPoint.y - containerRect.top;\n  const rightOverflow = getRightOverflow(x);\n\n  if (rightOverflow > 0) {\n    const adjustedX = x - menuRect.width;\n    const leftOverflow = getLeftOverflow(adjustedX);\n\n    if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n      x = adjustedX;\n    }\n\n    x = confineHorizontally(x);\n  }\n\n  let computedDirection = 'bottom';\n  const bottomOverflow = getBottomOverflow(y);\n\n  if (bottomOverflow > 0) {\n    const adjustedY = y - menuRect.height;\n    const topOverflow = getTopOverflow(adjustedY);\n\n    if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n      y = adjustedY;\n      computedDirection = 'top';\n    }\n\n    y = confineVertically(y);\n  }\n\n  return {\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowVertical = ({\n  arrowRef,\n  menuY,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let y = anchorRect.top - containerRect.top - menuY + anchorRect.height / 2;\n  const offset = arrowRef.current.offsetHeight * 1.25;\n  y = Math.max(offset, y);\n  y = Math.min(y, menuRect.height - offset);\n  return y;\n};\n\nconst placeLeftorRight = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeLeftorRightY,\n  placeLeftX,\n  placeRightX,\n  getLeftOverflow,\n  getRightOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction;\n  let y = placeLeftorRightY;\n\n  if (position !== 'initial') {\n    y = confineVertically(y);\n\n    if (position === 'anchor') {\n      y = Math.min(y, anchorRect.bottom - containerRect.top);\n      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);\n    }\n  }\n\n  let x, leftOverflow, rightOverflow;\n\n  if (computedDirection === 'left') {\n    x = placeLeftX;\n\n    if (position !== 'initial') {\n      leftOverflow = getLeftOverflow(x);\n\n      if (leftOverflow < 0) {\n        rightOverflow = getRightOverflow(placeRightX);\n\n        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {\n          x = placeRightX;\n          computedDirection = 'right';\n        }\n      }\n    }\n  } else {\n    x = placeRightX;\n\n    if (position !== 'initial') {\n      rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        leftOverflow = getLeftOverflow(placeLeftX);\n\n        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n          x = placeLeftX;\n          computedDirection = 'left';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') x = confineHorizontally(x);\n  const arrowY = arrow ? placeArrowVertical({\n    menuY: y,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowY,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowHorizontal = ({\n  arrowRef,\n  menuX,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let x = anchorRect.left - containerRect.left - menuX + anchorRect.width / 2;\n  const offset = arrowRef.current.offsetWidth * 1.25;\n  x = Math.max(offset, x);\n  x = Math.min(x, menuRect.width - offset);\n  return x;\n};\n\nconst placeToporBottom = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeToporBottomX,\n  placeTopY,\n  placeBottomY,\n  getTopOverflow,\n  getBottomOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction === 'top' ? 'top' : 'bottom';\n  let x = placeToporBottomX;\n\n  if (position !== 'initial') {\n    x = confineHorizontally(x);\n\n    if (position === 'anchor') {\n      x = Math.min(x, anchorRect.right - containerRect.left);\n      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);\n    }\n  }\n\n  let y, topOverflow, bottomOverflow;\n\n  if (computedDirection === 'top') {\n    y = placeTopY;\n\n    if (position !== 'initial') {\n      topOverflow = getTopOverflow(y);\n\n      if (topOverflow < 0) {\n        bottomOverflow = getBottomOverflow(placeBottomY);\n\n        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {\n          y = placeBottomY;\n          computedDirection = 'bottom';\n        }\n      }\n    }\n  } else {\n    y = placeBottomY;\n\n    if (position !== 'initial') {\n      bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        topOverflow = getTopOverflow(placeTopY);\n\n        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n          y = placeTopY;\n          computedDirection = 'top';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') y = confineVertically(y);\n  const arrowX = arrow ? placeArrowHorizontal({\n    menuX: x,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowX,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst positionMenu = ({\n  arrow,\n  align,\n  direction,\n  offsetX,\n  offsetY,\n  position,\n  anchorRef,\n  arrowRef,\n  positionHelpers\n}) => {\n  const {\n    menuRect,\n    containerRect\n  } = positionHelpers;\n  let horizontalOffset = offsetX;\n  let verticalOffset = offsetY;\n\n  if (arrow) {\n    if (direction === 'left' || direction === 'right') {\n      horizontalOffset += arrowRef.current.offsetWidth;\n    } else {\n      verticalOffset += arrowRef.current.offsetHeight;\n    }\n  }\n\n  const anchorRect = anchorRef.current.getBoundingClientRect();\n  const placeLeftX = anchorRect.left - containerRect.left - menuRect.width - horizontalOffset;\n  const placeRightX = anchorRect.right - containerRect.left + horizontalOffset;\n  const placeTopY = anchorRect.top - containerRect.top - menuRect.height - verticalOffset;\n  const placeBottomY = anchorRect.bottom - containerRect.top + verticalOffset;\n  let placeToporBottomX, placeLeftorRightY;\n\n  if (align === 'end') {\n    placeToporBottomX = anchorRect.right - containerRect.left - menuRect.width;\n    placeLeftorRightY = anchorRect.bottom - containerRect.top - menuRect.height;\n  } else if (align === 'center') {\n    placeToporBottomX = anchorRect.left - containerRect.left - (menuRect.width - anchorRect.width) / 2;\n    placeLeftorRightY = anchorRect.top - containerRect.top - (menuRect.height - anchorRect.height) / 2;\n  } else {\n    placeToporBottomX = anchorRect.left - containerRect.left;\n    placeLeftorRightY = anchorRect.top - containerRect.top;\n  }\n\n  placeToporBottomX += horizontalOffset;\n  placeLeftorRightY += verticalOffset;\n  const options = { ...positionHelpers,\n    anchorRect,\n    placeLeftX,\n    placeRightX,\n    placeLeftorRightY,\n    placeTopY,\n    placeBottomY,\n    placeToporBottomX,\n    arrowRef,\n    arrow,\n    direction,\n    position\n  };\n\n  switch (direction) {\n    case 'left':\n    case 'right':\n      return placeLeftorRight(options);\n\n    case 'top':\n    case 'bottom':\n    default:\n      return placeToporBottom(options);\n  }\n};\n\nconst MenuList = ({\n  ariaLabel,\n  menuClassName,\n  menuStyles,\n  arrowClassName,\n  arrowStyles,\n  anchorPoint,\n  anchorRef,\n  containerRef,\n  externalRef,\n  parentScrollingRef,\n  arrow,\n  align,\n  direction,\n  position,\n  overflow,\n  repositionFlag,\n  captureFocus: _captureFocus = true,\n  state: menuState,\n  endTransition,\n  isDisabled,\n  menuItemFocus,\n  offsetX,\n  offsetY,\n  children,\n  onClose,\n  ...restProps\n}) => {\n  const isOpen = isMenuOpen(menuState);\n  const [menuPosition, setMenuPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [arrowPosition, setArrowPosition] = useState({});\n  const [overflowData, setOverflowData] = useState();\n  const [expandedDirection, setExpandedDirection] = useState(direction);\n  const {\n    transition,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef,\n    rootAnchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  } = useContext(SettingsContext);\n  const menuRef = useRef(null);\n  const arrowRef = useRef(null);\n  const menuItemsCount = useRef(0);\n  const prevOpen = useRef(isOpen);\n  const latestMenuSize = useRef({\n    width: 0,\n    height: 0\n  });\n  const latestHandlePosition = useRef(() => {});\n  const descendOverflowRef = useRef(false);\n  const reposFlag = useContext(MenuListContext).reposSubmenu || repositionFlag;\n  const [reposSubmenu, forceReposSubmenu] = useReducer(c => c + 1, 1);\n  const [{\n    hoverIndex,\n    openSubmenuCount\n  }, dispatch] = useReducer(reducer, {\n    hoverIndex: initialHoverIndex,\n    openSubmenuCount: 0\n  });\n  const openTransition = getTransition(transition, 'open');\n  const closeTransition = getTransition(transition, 'close');\n\n  function reducer({\n    hoverIndex,\n    openSubmenuCount\n  }, action) {\n    return {\n      hoverIndex: hoverIndexReducer(hoverIndex, action),\n      openSubmenuCount: submenuCountReducer(openSubmenuCount, action)\n    };\n  }\n\n  function hoverIndexReducer(state, {\n    type,\n    index\n  }) {\n    switch (type) {\n      case HoverIndexActionTypes.RESET:\n        return initialHoverIndex;\n\n      case HoverIndexActionTypes.SET:\n        return index;\n\n      case HoverIndexActionTypes.UNSET:\n        return state === index ? initialHoverIndex : state;\n\n      case HoverIndexActionTypes.DECREASE:\n        {\n          let i = state;\n          i--;\n          if (i < 0) i = menuItemsCount.current - 1;\n          return i;\n        }\n\n      case HoverIndexActionTypes.INCREASE:\n        {\n          let i = state;\n          i++;\n          if (i >= menuItemsCount.current) i = 0;\n          return i;\n        }\n\n      case HoverIndexActionTypes.FIRST:\n        return menuItemsCount.current > 0 ? 0 : initialHoverIndex;\n\n      case HoverIndexActionTypes.LAST:\n        return menuItemsCount.current > 0 ? menuItemsCount.current - 1 : initialHoverIndex;\n\n      default:\n        return state;\n    }\n  }\n\n  const menuItems = useMemo(() => {\n    const {\n      items,\n      index,\n      descendOverflow\n    } = cloneChildren(children);\n    menuItemsCount.current = index;\n    descendOverflowRef.current = descendOverflow;\n    return items;\n  }, [children]);\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.HOME:\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n        handled = true;\n        break;\n\n      case Keys.END:\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n        handled = true;\n        break;\n\n      case Keys.UP:\n        dispatch({\n          type: HoverIndexActionTypes.DECREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        dispatch({\n          type: HoverIndexActionTypes.INCREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.SPACE:\n        if (e.target && e.target.className.indexOf(menuClass) !== -1) {\n          e.preventDefault();\n        }\n\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleAnimationEnd = () => {\n    if (menuState === 'closing') {\n      setOverflowData();\n    }\n\n    safeCall(endTransition);\n  };\n\n  const handlePosition = useCallback(() => {\n    if (!containerRef.current) {\n      if (!isProd) throw new Error('[React-Menu] Menu cannot be positioned properly as container ref is null. If you initialise isOpen prop to true for ControlledMenu, please see this link for a solution: https://github.com/szhsin/react-menu/issues/2#issuecomment-719166062');\n      return;\n    }\n\n    if (!scrollingRef.current) {\n      scrollingRef.current = boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current);\n    }\n\n    const positionHelpers = getPositionHelpers({\n      menuRef,\n      containerRef,\n      scrollingRef,\n      boundingBoxPadding\n    });\n    const {\n      menuRect\n    } = positionHelpers;\n    let results = {\n      computedDirection: 'bottom'\n    };\n\n    if (anchorPoint) {\n      results = positionContextMenu({\n        positionHelpers,\n        anchorPoint\n      });\n    } else if (anchorRef) {\n      results = positionMenu({\n        arrow,\n        align,\n        direction,\n        offsetX,\n        offsetY,\n        position,\n        anchorRef,\n        arrowRef,\n        positionHelpers\n      });\n    }\n\n    let {\n      arrowX,\n      arrowY,\n      x,\n      y,\n      computedDirection\n    } = results;\n    let menuHeight = menuRect.height;\n\n    if (overflow !== 'visible') {\n      const {\n        getTopOverflow,\n        getBottomOverflow\n      } = positionHelpers;\n      let height, overflowAmt;\n      const prevHeight = latestMenuSize.current.height;\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n        height = menuHeight - bottomOverflow;\n        overflowAmt = bottomOverflow;\n      } else {\n        const topOverflow = getTopOverflow(y);\n\n        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n          height = menuHeight + topOverflow;\n          overflowAmt = 0 - topOverflow;\n          if (height >= 0) y -= topOverflow;\n        }\n      }\n\n      if (height >= 0) {\n        menuHeight = height;\n        setOverflowData({\n          height,\n          overflowAmt\n        });\n      } else {\n        setOverflowData();\n      }\n    }\n\n    if (arrow) setArrowPosition({\n      x: arrowX,\n      y: arrowY\n    });\n    setMenuPosition({\n      x,\n      y\n    });\n    setExpandedDirection(computedDirection);\n    latestMenuSize.current = {\n      width: menuRect.width,\n      height: menuHeight\n    };\n  }, [arrow, align, boundingBoxPadding, direction, offsetX, offsetY, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollingRef]);\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      handlePosition();\n      if (prevOpen.current) forceReposSubmenu();\n    }\n\n    prevOpen.current = isOpen;\n    latestHandlePosition.current = handlePosition;\n  }, [isOpen, handlePosition, reposFlag]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowData && !descendOverflowRef.current) menuRef.current.scrollTop = 0;\n  }, [overflowData]);\n  useEffect(() => {\n    if (!isOpen) return;\n\n    if (!anchorScrollingRef.current && rootAnchorRef && rootAnchorRef.current.tagName) {\n      anchorScrollingRef.current = getScrollAncestor(rootAnchorRef.current);\n    }\n\n    const scrollCurrent = scrollingRef.current;\n    const menuScroll = scrollCurrent && scrollCurrent.addEventListener ? scrollCurrent : window;\n    const anchorScroll = anchorScrollingRef.current || menuScroll;\n    let scroll = viewScroll;\n    if (anchorScroll !== menuScroll && scroll === 'initial') scroll = 'auto';\n    if (scroll === 'initial') return;\n    if (scroll === 'auto' && overflow !== 'visible') scroll = 'close';\n\n    const handleScroll = () => {\n      if (scroll === 'auto') {\n        batchedUpdates(handlePosition);\n      } else {\n        safeCall(onClose, {\n          reason: CloseReason.SCROLL\n        });\n      }\n    };\n\n    const scrollObservers = anchorScroll !== menuScroll && viewScroll !== 'initial' ? [anchorScroll, menuScroll] : [anchorScroll];\n    scrollObservers.forEach(o => o.addEventListener('scroll', handleScroll));\n    return () => scrollObservers.forEach(o => o.removeEventListener('scroll', handleScroll));\n  }, [rootAnchorRef, anchorScrollingRef, scrollingRef, isOpen, overflow, onClose, viewScroll, handlePosition]);\n  const hasOverflow = !!overflowData && overflowData.overflowAmt > 0;\n  useEffect(() => {\n    if (hasOverflow || !isOpen || !parentScrollingRef) return;\n\n    const handleScroll = () => batchedUpdates(handlePosition);\n\n    const parentScroll = parentScrollingRef.current;\n    parentScroll.addEventListener('scroll', handleScroll);\n    return () => parentScroll.removeEventListener('scroll', handleScroll);\n  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);\n  useEffect(() => {\n    if (typeof ResizeObserver !== 'function' || reposition === 'initial') return;\n    const resizeObserver = new ResizeObserver(([entry]) => {\n      const {\n        borderBoxSize,\n        target\n      } = entry;\n      let width, height;\n\n      if (borderBoxSize) {\n        const {\n          inlineSize,\n          blockSize\n        } = borderBoxSize[0] || borderBoxSize;\n        width = inlineSize;\n        height = blockSize;\n      } else {\n        const borderRect = target.getBoundingClientRect();\n        width = borderRect.width;\n        height = borderRect.height;\n      }\n\n      if (width === 0 || height === 0) return;\n      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1)) return;\n      batchedUpdates(() => {\n        latestHandlePosition.current();\n        forceReposSubmenu();\n      });\n    });\n    const observeTarget = menuRef.current;\n    resizeObserver.observe(observeTarget, {\n      box: 'border-box'\n    });\n    return () => resizeObserver.unobserve(observeTarget);\n  }, [reposition]);\n  useEffect(() => {\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.RESET\n      });\n      if (!closeTransition) setOverflowData();\n      return;\n    }\n\n    const id = setTimeout(() => {\n      if (!menuRef.current) return;\n      const {\n        position,\n        alwaysUpdate\n      } = menuItemFocus || {};\n      if (!alwaysUpdate && menuRef.current.contains(document.activeElement)) return;\n      if (_captureFocus) menuRef.current.focus();\n\n      if (position === FocusPositions.FIRST) {\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n      } else if (position === FocusPositions.LAST) {\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n      } else if (position >= 0 && position < menuItemsCount.current) {\n        dispatch({\n          type: HoverIndexActionTypes.SET,\n          index: position\n        });\n      }\n    }, openTransition ? 170 : 100);\n    return () => clearTimeout(id);\n  }, [openTransition, closeTransition, _captureFocus, isOpen, menuItemFocus]);\n  const isSubmenuOpen = openSubmenuCount > 0;\n  const itemContext = useMemo(() => ({\n    parentMenuRef: menuRef,\n    parentOverflow: overflow,\n    isParentOpen: isOpen,\n    isSubmenuOpen,\n    dispatch\n  }), [isOpen, isSubmenuOpen, overflow]);\n  let maxHeight, overflowAmt;\n\n  if (overflowData) {\n    descendOverflowRef.current ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;\n  }\n\n  const listContext = useMemo(() => ({\n    reposSubmenu,\n    overflow,\n    overflowAmt\n  }), [reposSubmenu, overflow, overflowAmt]);\n  const overflowStyles = maxHeight >= 0 ? {\n    maxHeight,\n    overflow\n  } : undefined;\n  const modifiers = useMemo(() => ({\n    state: menuState,\n    dir: expandedDirection\n  }), [menuState, expandedDirection]);\n  const arrowModifiers = useMemo(() => Object.freeze({\n    dir: expandedDirection\n  }), [expandedDirection]);\n\n  const _arrowClass = useBEM({\n    block: menuClass,\n    element: menuArrowClass,\n    modifiers: arrowModifiers,\n    className: arrowClassName\n  });\n\n  const _arrowStyles = useFlatStyles(arrowStyles, arrowModifiers);\n\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onAnimationEnd: handleAnimationEnd\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"menu\",\n    tabIndex: \"-1\",\n    \"aria-disabled\": isDisabled || undefined,\n    \"aria-label\": ariaLabel\n  }, restProps, handlers, {\n    ref: useCombinedRef(externalRef, menuRef),\n    className: useBEM({\n      block: menuClass,\n      modifiers,\n      className: menuClassName\n    }),\n    style: { ...useFlatStyles(menuStyles, modifiers),\n      ...overflowStyles,\n      left: `${menuPosition.x}px`,\n      top: `${menuPosition.y}px`\n    }\n  }), arrow && /*#__PURE__*/React.createElement(\"div\", {\n    className: _arrowClass,\n    style: { ..._arrowStyles,\n      left: arrowPosition.x && `${arrowPosition.x}px`,\n      top: arrowPosition.y && `${arrowPosition.y}px`\n    },\n    ref: arrowRef\n  }), /*#__PURE__*/React.createElement(MenuListContext.Provider, {\n    value: listContext\n  }, /*#__PURE__*/React.createElement(MenuListItemContext.Provider, {\n    value: itemContext\n  }, /*#__PURE__*/React.createElement(HoverIndexContext.Provider, {\n    value: hoverIndex\n  }, menuItems))));\n};\n\nfunction submenuCountReducer(state, {\n  type\n}) {\n  switch (type) {\n    case SubmenuActionTypes.OPEN:\n      return state + 1;\n\n    case SubmenuActionTypes.CLOSE:\n      return Math.max(state - 1, 0);\n\n    default:\n      return state;\n  }\n}\n\nconst ControlledMenu = /*#__PURE__*/forwardRef(function ControlledMenu({\n  'aria-label': ariaLabel,\n  className,\n  containerProps,\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout,\n  boundingBoxRef,\n  boundingBoxPadding,\n  reposition,\n  submenuOpenDelay,\n  submenuCloseDelay,\n  skipOpen,\n  viewScroll,\n  portal,\n  theming,\n  onItemClick,\n  onClose,\n  ...restProps\n}, externalRef) {\n  const containerRef = useRef(null);\n  const scrollingRef = useRef(null);\n  const anchorScrollingRef = useRef(null);\n  const {\n    anchorRef,\n    state\n  } = restProps;\n  const settings = useMemo(() => ({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef: containerRef,\n    rootAnchorRef: anchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  }), [initialMounted, unmountOnClose, transition, transitionTimeout, anchorRef, boundingBoxRef, boundingBoxPadding, reposition, viewScroll]);\n  const itemSettings = useMemo(() => ({\n    submenuOpenDelay,\n    submenuCloseDelay\n  }), [submenuOpenDelay, submenuCloseDelay]);\n  const eventHandlers = useMemo(() => ({\n    handleClick(event, isCheckorRadio) {\n      if (!event.stopPropagation) safeCall(onItemClick, event);\n      let keepOpen = event.keepOpen;\n\n      if (keepOpen === undefined) {\n        keepOpen = isCheckorRadio && event.key === Keys.SPACE;\n      }\n\n      if (!keepOpen) {\n        safeCall(onClose, {\n          value: event.value,\n          key: event.key,\n          reason: CloseReason.CLICK\n        });\n      }\n    },\n\n    handleClose(key) {\n      safeCall(onClose, {\n        key,\n        reason: CloseReason.CLICK\n      });\n    }\n\n  }), [onItemClick, onClose]);\n\n  const handleKeyDown = ({\n    key\n  }) => {\n    switch (key) {\n      case Keys.ESC:\n        safeCall(onClose, {\n          key,\n          reason: CloseReason.CANCEL\n        });\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    if (isMenuOpen(state) && !e.currentTarget.contains(e.relatedTarget || document.activeElement)) {\n      safeCall(onClose, {\n        reason: CloseReason.BLUR\n      });\n\n      if (skipOpen) {\n        skipOpen.current = true;\n        setTimeout(() => skipOpen.current = false, 300);\n      }\n    }\n  };\n\n  const itemTransition = getTransition(transition, 'item');\n  const modifiers = useMemo(() => ({\n    theme: theming,\n    itemTransition\n  }), [theming, itemTransition]);\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur\n  }, containerProps);\n  const menuList = /*#__PURE__*/React.createElement(\"div\", Object.assign({}, containerProps, handlers, {\n    className: useBEM({\n      block: menuContainerClass,\n      modifiers,\n      className\n    }),\n    ref: containerRef\n  }), state && /*#__PURE__*/React.createElement(SettingsContext.Provider, {\n    value: settings\n  }, /*#__PURE__*/React.createElement(ItemSettingsContext.Provider, {\n    value: itemSettings\n  }, /*#__PURE__*/React.createElement(EventHandlersContext.Provider, {\n    value: eventHandlers\n  }, /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, {\n    ariaLabel: ariaLabel || 'Menu',\n    externalRef: externalRef,\n    containerRef: containerRef,\n    onClose: onClose\n  }))))));\n\n  if (portal) {\n    return /*#__PURE__*/ReactDOM.createPortal(menuList, document.body);\n  } else {\n    return menuList;\n  }\n});\nControlledMenu.propTypes = { ...rootMenuPropTypes,\n  state: PropTypes.oneOf(values(MenuStateMap)),\n  anchorPoint: PropTypes.exact({\n    x: PropTypes.number,\n    y: PropTypes.number\n  }),\n  anchorRef: PropTypes.object,\n  skipOpen: PropTypes.object,\n  captureFocus: PropTypes.bool,\n  menuItemFocus: PropTypes.exact({\n    position: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    alwaysUpdate: PropTypes.bool\n  }),\n  onClose: PropTypes.func\n};\nControlledMenu.defaultProps = { ...rootMenuDefaultProps,\n  menuItemFocus: {}\n};\nconst Menu = /*#__PURE__*/forwardRef(function Menu({\n  'aria-label': ariaLabel,\n  captureFocus: _,\n  menuButton,\n  instanceRef,\n  onMenuChange,\n  ...restProps\n}, externalRef) {\n  const {\n    openMenu,\n    toggleMenu,\n    ...stateProps\n  } = useMenuStateAndFocus(restProps);\n  const isOpen = isMenuOpen(stateProps.state);\n  const skipOpen = useRef(false);\n  const buttonRef = useRef(null);\n  const handleClose = useCallback(e => {\n    toggleMenu(false);\n    if (e.key) buttonRef.current.focus();\n  }, [toggleMenu]);\n\n  const handleClick = e => {\n    if (skipOpen.current) return;\n    openMenu(e.detail === 0 ? FocusPositions.FIRST : undefined);\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.UP:\n        openMenu(FocusPositions.LAST);\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        openMenu(FocusPositions.FIRST);\n        handled = true;\n        break;\n    }\n\n    if (handled) e.preventDefault();\n  };\n\n  const button = safeCall(menuButton, {\n    open: isOpen\n  });\n  if (!button) throw new Error('Menu requires a menuButton prop.');\n  const buttonProps = {\n    ref: useCombinedRef(button.ref, buttonRef),\n    ...attachHandlerProps({\n      onClick: handleClick,\n      onKeyDown: handleKeyDown\n    }, button.props)\n  };\n\n  if (getName(button.type) === 'MenuButton') {\n    buttonProps.isOpen = isOpen;\n  }\n\n  const renderButton = /*#__PURE__*/React.cloneElement(button, buttonProps);\n  useMenuChange(onMenuChange, isOpen);\n  useImperativeHandle(instanceRef, () => ({\n    openMenu,\n    closeMenu: () => toggleMenu(false)\n  }));\n  const menuProps = { ...restProps,\n    ...stateProps,\n    'aria-label': ariaLabel || (typeof button.props.children === 'string' ? button.props.children : 'Menu'),\n    anchorRef: buttonRef,\n    ref: externalRef,\n    onClose: handleClose,\n    skipOpen\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, renderButton, /*#__PURE__*/React.createElement(ControlledMenu, menuProps));\n});\nMenu.propTypes = { ...rootMenuPropTypes,\n  ...uncontrolledMenuPropTypes,\n  menuButton: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired\n};\nMenu.defaultProps = rootMenuDefaultProps;\nconst SubMenu = withHovering( /*#__PURE__*/memo(function SubMenu({\n  'aria-label': ariaLabel,\n  className,\n  disabled,\n  label,\n  index,\n  onMenuChange,\n  isHovering,\n  instanceRef,\n  captureFocus: _1,\n  repositionFlag: _2,\n  itemProps = {},\n  ...restProps\n}) {\n  const isDisabled = !!disabled;\n  validateIndex(index, isDisabled, label);\n  const {\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    rootMenuRef\n  } = useContext(SettingsContext);\n  const {\n    submenuOpenDelay,\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    parentMenuRef,\n    parentOverflow,\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const isPortal = parentOverflow !== 'visible';\n  const {\n    openMenu,\n    toggleMenu,\n    state,\n    ...otherStateProps\n  } = useMenuStateAndFocus({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout\n  });\n  const isOpen = isMenuOpen(state);\n  const {\n    isActive,\n    onKeyUp,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled, Keys.RIGHT);\n  const containerRef = useRef(null);\n  const itemRef = useRef(null);\n  const timeoutId = useRef();\n\n  const setHover = () => !isHovering && dispatch({\n    type: HoverIndexActionTypes.SET,\n    index\n  });\n\n  const delayOpen = delay => {\n    dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n    timeoutId.current = setTimeout(openMenu, Math.max(delay, 0));\n  };\n\n  const handleMouseEnter = () => {\n    if (isDisabled || isOpen) return;\n\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(() => delayOpen(submenuOpenDelay - submenuCloseDelay), submenuCloseDelay);\n    } else {\n      delayOpen(submenuOpenDelay);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    clearTimeout(timeoutId.current);\n\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const handleClick = () => {\n    if (isDisabled) return;\n    clearTimeout(timeoutId.current);\n    openMenu();\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.LEFT:\n        if (isOpen) {\n          itemRef.current.focus();\n          toggleMenu(false);\n          handled = true;\n        }\n\n        break;\n\n      case Keys.RIGHT:\n        if (!isOpen) handled = true;\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.ENTER:\n      case Keys.SPACE:\n      case Keys.RIGHT:\n        openMenu(FocusPositions.FIRST);\n        break;\n    }\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      itemRef.current.focus();\n    } else {\n      toggleMenu(false);\n    }\n  }, [isHovering, isParentOpen, toggleMenu]);\n  useEffect(() => {\n    dispatch({\n      type: isOpen ? SubmenuActionTypes.OPEN : SubmenuActionTypes.CLOSE\n    });\n  }, [dispatch, isOpen]);\n  useMenuChange(onMenuChange, isOpen);\n  useImperativeHandle(instanceRef, () => ({\n    openMenu: (...args) => {\n      if (isParentOpen) {\n        setHover();\n        openMenu(...args);\n      }\n    },\n    closeMenu: () => {\n      if (isOpen) {\n        itemRef.current.focus();\n        toggleMenu(false);\n      }\n    }\n  }));\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen,\n    hover: isHovering,\n    active: isActive,\n    disabled: isDisabled\n  }), [isOpen, isHovering, isActive, isDisabled]);\n  const {\n    ref: externaItemlRef,\n    className: itemClassName,\n    styles: itemStyles,\n    ...restItemProps\n  } = itemProps;\n  const itemHandlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onMouseDown: setHover,\n    onClick: handleClick,\n    onKeyUp: handleKeyUp\n  }, restItemProps);\n\n  const getMenuList = () => {\n    const menuList = /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, otherStateProps, {\n      state: state,\n      ariaLabel: ariaLabel || (typeof label === 'string' ? label : 'Submenu'),\n      anchorRef: itemRef,\n      containerRef: isPortal ? rootMenuRef : containerRef,\n      parentScrollingRef: isPortal && parentMenuRef,\n      isDisabled: isDisabled\n    }));\n    return isPortal ? /*#__PURE__*/createPortal(menuList, rootMenuRef.current) : menuList;\n  };\n\n  return /*#__PURE__*/React.createElement(\"li\", {\n    className: useBEM({\n      block: menuClass,\n      element: subMenuClass,\n      className\n    }),\n    role: \"presentation\",\n    ref: containerRef,\n    onKeyDown: handleKeyDown\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    role: \"menuitem\",\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": isDisabled || undefined,\n    tabIndex: isHovering && !isOpen ? 0 : -1\n  }, restItemProps, itemHandlers, {\n    ref: useCombinedRef(externaItemlRef, itemRef),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className: itemClassName\n    }),\n    style: useFlatStyles(itemStyles, modifiers)\n  }), useMemo(() => safeCall(label, modifiers), [label, modifiers])), state && getMenuList());\n}), 'SubMenu');\nSubMenu.propTypes = { ...menuPropTypes,\n  ...uncontrolledMenuPropTypes,\n  disabled: PropTypes.bool,\n  label: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  itemProps: PropTypes.shape({ ...stylePropTypes()\n  })\n};\nSubMenu.defaultProps = { ...menuDefaultProps,\n  direction: 'right'\n};\nconst MenuItem = withHovering( /*#__PURE__*/memo(function MenuItem({\n  className,\n  styles,\n  value,\n  href,\n  type,\n  checked,\n  disabled,\n  index,\n  children,\n  onClick,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = !!disabled;\n  validateIndex(index, isDisabled, children);\n  const ref = useRef();\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const eventHandlers = useContext(EventHandlersContext);\n  const radioGroup = useContext(RadioGroupContext);\n  const {\n    isActive,\n    onKeyUp,\n    onBlur: activeStateBlur,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled);\n  const isRadio = type === 'radio';\n  const isCheckBox = type === 'checkbox';\n  const isAnchor = !!href && !isDisabled && !isRadio && !isCheckBox;\n  const isChecked = isRadio ? radioGroup.value === value : isCheckBox ? !!checked : false;\n\n  const handleClick = e => {\n    if (isDisabled) return;\n    const event = {\n      value,\n      syntheticEvent: e\n    };\n    if (e.key !== undefined) event.key = e.key;\n    if (isCheckBox) event.checked = !isChecked;\n\n    if (isRadio) {\n      event.name = radioGroup.name;\n      safeCall(radioGroup.onRadioChange, event);\n    }\n\n    if (!event.stopPropagation) safeCall(onClick, event);\n    eventHandlers.handleClick(event, isCheckBox || isRadio);\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.ENTER:\n      case Keys.SPACE:\n        if (isAnchor) {\n          ref.current.click();\n        } else {\n          handleClick(e);\n        }\n\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    activeStateBlur(e);\n    onBlur(e);\n  };\n\n  const modifiers = useMemo(() => Object.freeze({\n    type,\n    disabled: isDisabled,\n    hover: isHovering,\n    active: isActive,\n    checked: isChecked,\n    anchor: isAnchor\n  }), [type, isDisabled, isHovering, isActive, isChecked, isAnchor]);\n  const handlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown: setHover,\n    onKeyUp: handleKeyUp,\n    onBlur: handleBlur,\n    onClick: handleClick\n  }, restProps);\n  const menuItemProps = {\n    role: isRadio ? 'menuitemradio' : isCheckBox ? 'menuitemcheckbox' : 'menuitem',\n    'aria-checked': isRadio || isCheckBox ? isChecked : undefined,\n    'aria-disabled': isDisabled || undefined,\n    tabIndex: isHovering ? 0 : -1,\n    ...restProps,\n    ...handlers,\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  };\n  const renderChildren = useMemo(() => safeCall(children, modifiers), [children, modifiers]);\n\n  if (isAnchor) {\n    return /*#__PURE__*/React.createElement(\"li\", {\n      role: \"presentation\"\n    }, /*#__PURE__*/React.createElement(\"a\", Object.assign({}, menuItemProps, {\n      href: href\n    }), renderChildren));\n  } else {\n    return /*#__PURE__*/React.createElement(\"li\", menuItemProps, renderChildren);\n  }\n}), 'MenuItem');\nMenuItem.propTypes = { ...stylePropTypes(),\n  value: PropTypes.any,\n  href: PropTypes.string,\n  type: PropTypes.oneOf(['checkbox', 'radio']),\n  checked: PropTypes.bool,\n  disabled: PropTypes.bool,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  onClick: PropTypes.func\n};\nconst FocusableItem = withHovering( /*#__PURE__*/memo(function FocusableItem({\n  className,\n  styles,\n  disabled,\n  index,\n  children,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = !!disabled;\n  validateIndex(index, isDisabled, children);\n  const ref = useRef(null);\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const {\n    handleClose\n  } = useContext(EventHandlersContext);\n  const modifiers = useMemo(() => Object.freeze({\n    disabled: isDisabled,\n    hover: isHovering,\n    focusable: true\n  }), [isDisabled, isHovering]);\n  const renderChildren = useMemo(() => safeCall(children, { ...modifiers,\n    ref,\n    closeMenu: handleClose\n  }), [children, modifiers, handleClose]);\n  const handlers = attachHandlerProps({\n    onMouseEnter,\n    onMouseLeave: e => onMouseLeave(e, true),\n    onFocus: setHover,\n    onBlur\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    \"aria-disabled\": isDisabled || undefined,\n    role: \"menuitem\",\n    tabIndex: \"-1\"\n  }, restProps, handlers, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), renderChildren);\n}), 'FocusableItem');\nFocusableItem.propTypes = { ...stylePropTypes(),\n  disabled: PropTypes.bool,\n  children: PropTypes.func\n};\nconst MenuDivider = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuDivider({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"separator\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuDividerClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n}));\nMenuDivider.propTypes = { ...stylePropTypes()\n};\nconst MenuHeader = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuHeader({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"presentation\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuHeaderClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n}));\nMenuHeader.propTypes = { ...stylePropTypes()\n};\nconst MenuGroup = defineName( /*#__PURE__*/forwardRef(function MenuGroup({\n  className,\n  styles,\n  takeOverflow,\n  ...restProps\n}, externalRef) {\n  const ref = useRef(null);\n  const [overflowStyles, setOverflowStyles] = useState();\n  const {\n    overflow,\n    overflowAmt\n  } = useContext(MenuListContext);\n  useIsomorphicLayoutEffect(() => {\n    let maxHeight;\n\n    if (takeOverflow && overflowAmt >= 0) {\n      maxHeight = ref.current.getBoundingClientRect().height - overflowAmt;\n      if (maxHeight < 0) maxHeight = 0;\n    }\n\n    setOverflowStyles(maxHeight >= 0 ? {\n      maxHeight,\n      overflow\n    } : undefined);\n  }, [takeOverflow, overflow, overflowAmt]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowStyles) ref.current.scrollTop = 0;\n  }, [overflowStyles]);\n  return /*#__PURE__*/React.createElement(\"div\", Object.assign({}, restProps, {\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuGroupClass,\n      className\n    }),\n    style: { ...useFlatStyles(styles),\n      ...overflowStyles\n    }\n  }));\n}), 'MenuGroup');\nMenuGroup.propTypes = { ...stylePropTypes(),\n  takeOverflow: PropTypes.bool\n};\nconst MenuRadioGroup = defineName( /*#__PURE__*/forwardRef(function MenuRadioGroup({\n  'aria-label': ariaLabel,\n  className,\n  styles,\n  name,\n  value,\n  onRadioChange,\n  ...restProps\n}, externalRef) {\n  const contextValue = useMemo(() => ({\n    name,\n    value,\n    onRadioChange\n  }), [name, value, onRadioChange]);\n  return /*#__PURE__*/React.createElement(RadioGroupContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    role: \"presentation\"\n  }, /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"group\",\n    \"aria-label\": ariaLabel || name || 'Radio group'\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: radioGroupClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }))));\n}), 'MenuRadioGroup');\nMenuRadioGroup.propTypes = { ...stylePropTypes(),\n  name: PropTypes.string,\n  value: PropTypes.any,\n  onRadioChange: PropTypes.func\n};\nexport { ControlledMenu, FocusableItem, Menu, MenuButton, MenuDivider, MenuGroup, MenuHeader, MenuItem, MenuRadioGroup, SubMenu, applyHOC, applyStatics, useMenuState };","map":{"version":3,"sources":["/home/rr/Workspace/Js/falcon_face/node_modules/@szhsin/react-menu/dist/index.modern.js"],"names":["React","Children","cloneElement","forwardRef","useContext","useState","useMemo","useLayoutEffect","useEffect","useRef","useReducer","useCallback","useImperativeHandle","memo","ReactDOM","unstable_batchedUpdates","createPortal","PropTypes","useTransition","menuContainerClass","menuClass","menuButtonClass","menuArrowClass","menuItemClass","menuDividerClass","menuHeaderClass","menuGroupClass","subMenuClass","radioGroupClass","initialHoverIndex","HoverIndexContext","createContext","MenuListItemContext","MenuListContext","EventHandlersContext","RadioGroupContext","SettingsContext","ItemSettingsContext","Keys","Object","freeze","HoverIndexActionTypes","SubmenuActionTypes","CloseReason","FocusPositions","MenuStateMap","entering","entered","exiting","exited","isProd","process","env","NODE_ENV","isMenuOpen","state","batchedUpdates","callback","values","obj","keys","map","key","floatEqual","a","b","diff","Math","abs","getTransition","transition","name","safeCall","fn","args","getName","component","defineName","defineProperty","value","writable","applyHOC","HOC","applyStatics","sourceComponent","wrappedComponent","attachHandlerProps","handlers","props","result","handlerName","handler","propHandler","attachedHandler","e","parsePadding","paddingStr","top","right","bottom","left","padding","trim","split","parseFloat","isNaN","getScrollAncestor","node","document","body","overflow","overflowX","overflowY","getComputedStyle","test","parentNode","window","validateIndex","index","isDisabled","undefined","error","toString","Error","cloneChildren","children","startIndex","inRadioGroup","descendOverflow","items","child","type","disabled","innerChildren","desc","takeOverflow","descOverflow","stylePropTypes","oneOfType","string","func","object","menuPropTypes","className","arrow","bool","offsetX","number","offsetY","align","oneOf","direction","position","rootMenuPropTypes","containerProps","initialMounted","unmountOnClose","exact","open","close","item","transitionTimeout","boundingBoxRef","boundingBoxPadding","reposition","repositionFlag","viewScroll","submenuOpenDelay","submenuCloseDelay","portal","theming","onItemClick","uncontrolledMenuPropTypes","instanceRef","onMenuChange","menuDefaultProps","rootMenuDefaultProps","withHovering","WrapppedComponent","WithHovering","ref","createElement","assign","externalRef","isHovering","displayName","useActiveState","moreKeys","active","setActive","activeKeys","ENTER","SPACE","cancelActive","isActive","onPointerDown","onPointerUp","onPointerLeave","onKeyDown","indexOf","onKeyUp","onBlur","currentTarget","contains","relatedTarget","useBEM","block","element","modifiers","blockElement","classString","expandedClassName","setRef","current","useCombinedRef","refA","refB","isObject","sanitiseKey","slice","useFlatStyles","styles","style","prop","modifierValue","nestedProp","nestedValue","useIsomorphicLayoutEffect","useItemState","isParentOpen","isSubmenuOpen","dispatch","timeoutId","setHover","SET","UNSET","onMouseEnter","setTimeout","onMouseLeave","_","keepHover","clearTimeout","focus","useMenuChange","isOpen","prevOpen","useMenuState","toggleMenu","endTransition","mountOnEnter","unmountOnExit","timeout","enter","exit","useMenuStateAndFocus","options","menuState","menuItemFocus","setMenuItemFocus","openMenu","alwaysUpdate","MenuButton","restProps","propTypes","getPositionHelpers","menuRef","containerRef","scrollingRef","menuRect","getBoundingClientRect","containerRect","boundingRect","documentElement","clientWidth","innerHeight","getLeftOverflow","x","getRightOverflow","width","getTopOverflow","y","getBottomOverflow","height","confineHorizontally","leftOverflow","rightOverflow","confineVertically","topOverflow","bottomOverflow","positionContextMenu","positionHelpers","anchorPoint","adjustedX","computedDirection","adjustedY","placeArrowVertical","arrowRef","menuY","anchorRect","offset","offsetHeight","max","min","placeLeftorRight","placeLeftorRightY","placeLeftX","placeRightX","arrowY","placeArrowHorizontal","menuX","offsetWidth","placeToporBottom","placeToporBottomX","placeTopY","placeBottomY","arrowX","positionMenu","anchorRef","horizontalOffset","verticalOffset","MenuList","ariaLabel","menuClassName","menuStyles","arrowClassName","arrowStyles","parentScrollingRef","captureFocus","_captureFocus","onClose","menuPosition","setMenuPosition","arrowPosition","setArrowPosition","overflowData","setOverflowData","expandedDirection","setExpandedDirection","rootMenuRef","rootAnchorRef","anchorScrollingRef","menuItemsCount","latestMenuSize","latestHandlePosition","descendOverflowRef","reposFlag","reposSubmenu","forceReposSubmenu","c","hoverIndex","openSubmenuCount","reducer","openTransition","closeTransition","action","hoverIndexReducer","submenuCountReducer","RESET","DECREASE","i","INCREASE","FIRST","LAST","menuItems","handleKeyDown","handled","HOME","END","UP","DOWN","target","preventDefault","stopPropagation","handleAnimationEnd","handlePosition","results","menuHeight","overflowAmt","prevHeight","scrollTop","tagName","scrollCurrent","menuScroll","addEventListener","anchorScroll","scroll","handleScroll","reason","SCROLL","scrollObservers","forEach","o","removeEventListener","hasOverflow","parentScroll","ResizeObserver","resizeObserver","entry","borderBoxSize","inlineSize","blockSize","borderRect","observeTarget","observe","box","unobserve","id","activeElement","itemContext","parentMenuRef","parentOverflow","maxHeight","listContext","overflowStyles","dir","arrowModifiers","_arrowClass","_arrowStyles","onAnimationEnd","role","tabIndex","Provider","OPEN","CLOSE","ControlledMenu","skipOpen","settings","itemSettings","eventHandlers","handleClick","event","isCheckorRadio","keepOpen","CLICK","handleClose","ESC","CANCEL","handleBlur","BLUR","itemTransition","theme","menuList","defaultProps","Menu","menuButton","stateProps","buttonRef","detail","button","buttonProps","onClick","renderButton","closeMenu","menuProps","Fragment","isRequired","SubMenu","label","_1","_2","itemProps","isPortal","otherStateProps","activeStateHandlers","RIGHT","itemRef","delayOpen","delay","handleMouseEnter","handleMouseLeave","LEFT","handleKeyUp","hover","externaItemlRef","itemClassName","itemStyles","restItemProps","itemHandlers","onMouseDown","getMenuList","shape","MenuItem","href","checked","radioGroup","activeStateBlur","isRadio","isCheckBox","isAnchor","isChecked","syntheticEvent","onRadioChange","click","anchor","menuItemProps","renderChildren","any","FocusableItem","focusable","onFocus","MenuDivider","MenuHeader","MenuGroup","setOverflowStyles","MenuRadioGroup","contextValue"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,YAA1B,EAAwCC,UAAxC,EAAoDC,UAApD,EAAgEC,QAAhE,EAA0EC,OAA1E,EAAmFC,eAAnF,EAAoGC,SAApG,EAA+GC,MAA/G,EAAuHC,UAAvH,EAAmIC,WAAnI,EAAgJC,mBAAhJ,EAAqKC,IAArK,QAAiL,OAAjL;AACA,OAAOC,QAAP,IAAmBC,uBAAnB,EAA4CC,YAA5C,QAAgE,WAAhE;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,SAASC,aAAT,QAA8B,wBAA9B;AAEA,MAAMC,kBAAkB,GAAG,oBAA3B;AACA,MAAMC,SAAS,GAAG,UAAlB;AACA,MAAMC,eAAe,GAAG,iBAAxB;AACA,MAAMC,cAAc,GAAG,OAAvB;AACA,MAAMC,aAAa,GAAG,MAAtB;AACA,MAAMC,gBAAgB,GAAG,SAAzB;AACA,MAAMC,eAAe,GAAG,QAAxB;AACA,MAAMC,cAAc,GAAG,OAAvB;AACA,MAAMC,YAAY,GAAG,SAArB;AACA,MAAMC,eAAe,GAAG,aAAxB;AACA,MAAMC,iBAAiB,GAAG,CAAC,CAA3B;AACA,MAAMC,iBAAiB,GAAG,aAAa9B,KAAK,CAAC+B,aAAN,CAAoBF,iBAApB,CAAvC;AACA,MAAMG,mBAAmB,GAAG,aAAahC,KAAK,CAAC+B,aAAN,CAAoB,EAApB,CAAzC;AACA,MAAME,eAAe,GAAG,aAAajC,KAAK,CAAC+B,aAAN,CAAoB,EAApB,CAArC;AACA,MAAMG,oBAAoB,GAAG,aAAalC,KAAK,CAAC+B,aAAN,CAAoB,EAApB,CAA1C;AACA,MAAMI,iBAAiB,GAAG,aAAanC,KAAK,CAAC+B,aAAN,CAAoB,EAApB,CAAvC;AACA,MAAMK,eAAe,GAAG,aAAapC,KAAK,CAAC+B,aAAN,CAAoB,EAApB,CAArC;AACA,MAAMM,mBAAmB,GAAG,aAAarC,KAAK,CAAC+B,aAAN,CAAoB,EAApB,CAAzC;AACA,MAAMO,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;AACzB,WAAS,OADgB;AAEzB,SAAO,QAFkB;AAGzB,WAAS,GAHgB;AAIzB,UAAQ,MAJiB;AAKzB,SAAO,KALkB;AAMzB,UAAQ,WANiB;AAOzB,WAAS,YAPgB;AAQzB,QAAM,SARmB;AASzB,UAAQ;AATiB,CAAd,CAAb;AAWA,MAAMC,qBAAqB,GAAGF,MAAM,CAACC,MAAP,CAAc;AAC1C,WAAS,aADiC;AAE1C,SAAO,WAFmC;AAG1C,WAAS,aAHiC;AAI1C,cAAY,gBAJ8B;AAK1C,cAAY,gBAL8B;AAM1C,WAAS,aANiC;AAO1C,UAAQ;AAPkC,CAAd,CAA9B;AASA,MAAME,kBAAkB,GAAGH,MAAM,CAACC,MAAP,CAAc;AACvC,UAAQ,cAD+B;AAEvC,WAAS;AAF8B,CAAd,CAA3B;AAIA,MAAMG,WAAW,GAAGJ,MAAM,CAACC,MAAP,CAAc;AAChC,WAAS,OADuB;AAEhC,YAAU,QAFsB;AAGhC,UAAQ,MAHwB;AAIhC,YAAU;AAJsB,CAAd,CAApB;AAMA,MAAMI,cAAc,GAAGL,MAAM,CAACC,MAAP,CAAc;AACnC,aAAW,SADwB;AAEnC,WAAS,OAF0B;AAGnC,UAAQ;AAH2B,CAAd,CAAvB;AAKA,MAAMK,YAAY,GAAGN,MAAM,CAACC,MAAP,CAAc;AACjCM,EAAAA,QAAQ,EAAE,SADuB;AAEjCC,EAAAA,OAAO,EAAE,MAFwB;AAGjCC,EAAAA,OAAO,EAAE,SAHwB;AAIjCC,EAAAA,MAAM,EAAE;AAJyB,CAAd,CAArB;AAOA,MAAMC,MAAM,GAAGC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAxC;;AACA,MAAMC,UAAU,GAAGC,KAAK,IAAI,CAAC,CAACA,KAAF,IAAWA,KAAK,CAAC,CAAD,CAAL,KAAa,GAApD;;AACA,MAAMC,cAAc,GAAGzC,uBAAuB,KAAK0C,QAAQ,IAAIA,QAAQ,EAAzB,CAA9C;;AACA,MAAMC,MAAM,GAAGnB,MAAM,CAACmB,MAAP,KAAkBC,GAAG,IAAIpB,MAAM,CAACqB,IAAP,CAAYD,GAAZ,EAAiBE,GAAjB,CAAqBC,GAAG,IAAIH,GAAG,CAACG,GAAD,CAA/B,CAAzB,CAAf;;AACA,MAAMC,UAAU,GAAG,CAACC,CAAD,EAAIC,CAAJ,EAAOC,IAAI,GAAG,MAAd,KAAyBC,IAAI,CAACC,GAAL,CAASJ,CAAC,GAAGC,CAAb,IAAkBC,IAA9D;;AACA,MAAMG,aAAa,GAAG,CAACC,UAAD,EAAaC,IAAb,KAAsB,CAAC,EAAED,UAAU,IAAIA,UAAU,CAACC,IAAD,CAA1B,CAAD,IAAsCD,UAAU,KAAK,IAAjG;;AACA,MAAME,QAAQ,GAAG,CAACC,EAAD,EAAK,GAAGC,IAAR,KAAiB,OAAOD,EAAP,KAAc,UAAd,GAA2BA,EAAE,CAAC,GAAGC,IAAJ,CAA7B,GAAyCD,EAA3E;;AACA,MAAME,OAAO,GAAGC,SAAS,IAAIA,SAAS,IAAIA,SAAS,CAAC,aAAD,CAAnD;;AACA,MAAMC,UAAU,GAAG,CAACD,SAAD,EAAYL,IAAZ,KAAqBA,IAAI,GAAGhC,MAAM,CAACuC,cAAP,CAAsBF,SAAtB,EAAiC,aAAjC,EAAgD;AAC7FG,EAAAA,KAAK,EAAER,IADsF;AAE7FS,EAAAA,QAAQ,EAAE;AAFmF,CAAhD,CAAH,GAGvCJ,SAHL;;AAIA,MAAMK,QAAQ,GAAGC,GAAG,IAAI,CAAC,GAAGR,IAAJ,KAAaG,UAAU,CAACK,GAAG,CAAC,GAAGR,IAAJ,CAAJ,EAAeC,OAAO,CAACD,IAAI,CAAC,CAAD,CAAL,CAAtB,CAA/C;;AACA,MAAMS,YAAY,GAAGC,eAAe,IAAIC,gBAAgB,IAAIR,UAAU,CAACQ,gBAAD,EAAmBV,OAAO,CAACS,eAAD,CAA1B,CAAtE;;AACA,MAAME,kBAAkB,GAAG,CAACC,QAAD,EAAWC,KAAX,KAAqB;AAC9C,MAAI,CAACA,KAAL,EAAY,OAAOD,QAAP;AACZ,QAAME,MAAM,GAAG,EAAf;;AAEA,OAAK,MAAMC,WAAX,IAA0BnD,MAAM,CAACqB,IAAP,CAAY2B,QAAZ,CAA1B,EAAiD;AAC/C,UAAMI,OAAO,GAAGJ,QAAQ,CAACG,WAAD,CAAxB;AACA,UAAME,WAAW,GAAGJ,KAAK,CAACE,WAAD,CAAzB;AACA,QAAIG,eAAJ;;AAEA,QAAI,OAAOD,WAAP,KAAuB,UAA3B,EAAuC;AACrCC,MAAAA,eAAe,GAAGC,CAAC,IAAI;AACrBF,QAAAA,WAAW,CAACE,CAAD,CAAX;AACAH,QAAAA,OAAO,CAACG,CAAD,CAAP;AACD,OAHD;AAID,KALD,MAKO;AACLD,MAAAA,eAAe,GAAGF,OAAlB;AACD;;AAEDF,IAAAA,MAAM,CAACC,WAAD,CAAN,GAAsBG,eAAtB;AACD;;AAED,SAAOJ,MAAP;AACD,CAtBD;;AAuBA,MAAMM,YAAY,GAAGC,UAAU,IAAI;AACjC,MAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC,OAAO;AACzCC,IAAAA,GAAG,EAAE,CADoC;AAEzCC,IAAAA,KAAK,EAAE,CAFkC;AAGzCC,IAAAA,MAAM,EAAE,CAHiC;AAIzCC,IAAAA,IAAI,EAAE;AAJmC,GAAP;AAMpC,QAAMC,OAAO,GAAGL,UAAU,CAACM,IAAX,GAAkBC,KAAlB,CAAwB,KAAxB,EAA+B,CAA/B,EAAkC1C,GAAlC,CAAsC2C,UAAtC,CAAhB;AACA,QAAMP,GAAG,GAAG,CAACQ,KAAK,CAACJ,OAAO,CAAC,CAAD,CAAR,CAAN,GAAqBA,OAAO,CAAC,CAAD,CAA5B,GAAkC,CAA9C;AACA,QAAMH,KAAK,GAAG,CAACO,KAAK,CAACJ,OAAO,CAAC,CAAD,CAAR,CAAN,GAAqBA,OAAO,CAAC,CAAD,CAA5B,GAAkCJ,GAAhD;AACA,SAAO;AACLA,IAAAA,GADK;AAELC,IAAAA,KAFK;AAGLC,IAAAA,MAAM,EAAE,CAACM,KAAK,CAACJ,OAAO,CAAC,CAAD,CAAR,CAAN,GAAqBA,OAAO,CAAC,CAAD,CAA5B,GAAkCJ,GAHrC;AAILG,IAAAA,IAAI,EAAE,CAACK,KAAK,CAACJ,OAAO,CAAC,CAAD,CAAR,CAAN,GAAqBA,OAAO,CAAC,CAAD,CAA5B,GAAkCH;AAJnC,GAAP;AAMD,CAhBD;;AAiBA,MAAMQ,iBAAiB,GAAGC,IAAI,IAAI;AAChC,SAAOA,IAAI,IAAIA,IAAI,KAAKC,QAAQ,CAACC,IAAjC,EAAuC;AACrC,UAAM;AACJC,MAAAA,QADI;AAEJC,MAAAA,SAFI;AAGJC,MAAAA;AAHI,QAIFC,gBAAgB,CAACN,IAAD,CAJpB;AAKA,QAAI,6BAA6BO,IAA7B,CAAkCJ,QAAQ,GAAGE,SAAX,GAAuBD,SAAzD,CAAJ,EAAyE,OAAOJ,IAAP;AACzEA,IAAAA,IAAI,GAAGA,IAAI,CAACQ,UAAZ;AACD;;AAED,SAAOC,MAAP;AACD,CAZD;;AAaA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,UAAR,EAAoBZ,IAApB,KAA6B;AACjD,MAAI,CAACzD,MAAD,IAAWoE,KAAK,KAAKE,SAArB,IAAkC,CAACD,UAAvC,EAAmD;AACjD,UAAME,KAAK,GAAI,+BAA8Bd,IAAI,IAAIA,IAAI,CAACe,QAAL,EAAgB;AACzE;AACA;AACA,mEAHI;AAIA,UAAM,IAAIC,KAAJ,CAAUF,KAAV,CAAN;AACD;AACF,CARD;;AAUA,MAAMG,aAAa,GAAG,CAACC,QAAD,EAAWC,UAAU,GAAG,CAAxB,EAA2BC,YAA3B,KAA4C;AAChE,MAAIT,KAAK,GAAGQ,UAAZ;AACA,MAAIE,eAAe,GAAG,KAAtB;AACA,QAAMC,KAAK,GAAGhI,QAAQ,CAAC4D,GAAT,CAAagE,QAAb,EAAuBK,KAAK,IAAI;AAC5C,QAAIA,KAAK,KAAKV,SAAV,IAAuBU,KAAK,KAAK,IAArC,EAA2C,OAAO,IAAP;AAC3C,QAAI,CAACA,KAAK,CAACC,IAAX,EAAiB,OAAOD,KAAP;AACjB,UAAM3D,IAAI,GAAGI,OAAO,CAACuD,KAAK,CAACC,IAAP,CAApB;;AAEA,YAAQ5D,IAAR;AACE,WAAK,UAAL;AACE;AACE,cAAIwD,YAAJ,EAAkB;AAChB,kBAAMvC,KAAK,GAAG;AACZ2C,cAAAA,IAAI,EAAE;AADM,aAAd;AAGA,gBAAI,CAACD,KAAK,CAAC1C,KAAN,CAAY4C,QAAjB,EAA2B5C,KAAK,CAAC8B,KAAN,GAAcA,KAAK,EAAnB;AAC3B,mBAAO,aAAapH,YAAY,CAACgI,KAAD,EAAQ1C,KAAR,CAAhC;AACD;AACF;;AAEH,WAAK,SAAL;AACA,WAAK,eAAL;AACE,eAAO0C,KAAK,CAAC1C,KAAN,CAAY4C,QAAZ,GAAuBF,KAAvB,GAA+B,aAAahI,YAAY,CAACgI,KAAD,EAAQ;AACrEZ,UAAAA,KAAK,EAAEA,KAAK;AADyD,SAAR,CAA/D;;AAIF;AACE;AACE,gBAAMe,aAAa,GAAGH,KAAK,CAAC1C,KAAN,CAAYqC,QAAlC;AACA,cAAIQ,aAAa,KAAK,IAAlB,IAA0B,OAAOA,aAAP,KAAyB,QAAvD,EAAiE,OAAOH,KAAP;AACjE,gBAAMI,IAAI,GAAGV,aAAa,CAACS,aAAD,EAAgBf,KAAhB,EAAuBS,YAAY,IAAIxD,IAAI,KAAK,gBAAhD,CAA1B;AACA+C,UAAAA,KAAK,GAAGgB,IAAI,CAAChB,KAAb;;AAEA,cAAI/C,IAAI,KAAK,WAAb,EAA0B;AACxB,kBAAMgE,YAAY,GAAG,CAAC,CAACL,KAAK,CAAC1C,KAAN,CAAY+C,YAAnC;AACA,kBAAMC,YAAY,GAAGF,IAAI,CAACN,eAA1B;AACA,gBAAI,CAAC9E,MAAD,KAAY8E,eAAe,KAAKQ,YAApB,GAAmCA,YAAnC,GAAkDD,YAA9D,CAAJ,EAAiF,MAAM,IAAIZ,KAAJ,CAAU,iFAAV,CAAN;AACjFK,YAAAA,eAAe,GAAGA,eAAe,IAAIQ,YAAnB,IAAmCD,YAArD;AACD;;AAED,iBAAO,aAAarI,YAAY,CAACgI,KAAD,EAAQ;AACtCL,YAAAA,QAAQ,EAAES,IAAI,CAACL;AADuB,WAAR,CAAhC;AAGD;AAnCL;AAqCD,GA1Ca,CAAd;AA2CA,SAAO;AACLA,IAAAA,KADK;AAELX,IAAAA,KAFK;AAGLU,IAAAA;AAHK,GAAP;AAKD,CAnDD;;AAqDA,MAAMS,cAAc,GAAGlE,IAAI,KAAK;AAC9B,GAACA,IAAI,GAAI,GAAEA,IAAK,WAAX,GAAwB,WAA7B,GAA2CtD,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC0H,MAAX,EAAmB1H,SAAS,CAAC2H,IAA7B,CAApB,CADb;AAE9B,GAACrE,IAAI,GAAI,GAAEA,IAAK,QAAX,GAAqB,QAA1B,GAAqCtD,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC4H,MAAX,EAAmB5H,SAAS,CAAC2H,IAA7B,CAApB;AAFP,CAAL,CAA3B;;AAIA,MAAME,aAAa,GAAG;AACpBC,EAAAA,SAAS,EAAE9H,SAAS,CAAC0H,MADD;AAEpB,KAAGF,cAAc,CAAC,MAAD,CAFG;AAGpB,KAAGA,cAAc,CAAC,OAAD,CAHG;AAIpBO,EAAAA,KAAK,EAAE/H,SAAS,CAACgI,IAJG;AAKpBC,EAAAA,OAAO,EAAEjI,SAAS,CAACkI,MALC;AAMpBC,EAAAA,OAAO,EAAEnI,SAAS,CAACkI,MANC;AAOpBE,EAAAA,KAAK,EAAEpI,SAAS,CAACqI,KAAV,CAAgB,CAAC,OAAD,EAAU,QAAV,EAAoB,KAApB,CAAhB,CAPa;AAQpBC,EAAAA,SAAS,EAAEtI,SAAS,CAACqI,KAAV,CAAgB,CAAC,MAAD,EAAS,OAAT,EAAkB,KAAlB,EAAyB,QAAzB,CAAhB,CARS;AASpBE,EAAAA,QAAQ,EAAEvI,SAAS,CAACqI,KAAV,CAAgB,CAAC,MAAD,EAAS,QAAT,EAAmB,SAAnB,CAAhB,CATU;AAUpBxC,EAAAA,QAAQ,EAAE7F,SAAS,CAACqI,KAAV,CAAgB,CAAC,MAAD,EAAS,SAAT,EAAoB,QAApB,CAAhB;AAVU,CAAtB;AAYA,MAAMG,iBAAiB,GAAG,EAAE,GAAGX,aAAL;AACxBY,EAAAA,cAAc,EAAEzI,SAAS,CAAC4H,MADF;AAExBc,EAAAA,cAAc,EAAE1I,SAAS,CAACgI,IAFF;AAGxBW,EAAAA,cAAc,EAAE3I,SAAS,CAACgI,IAHF;AAIxB3E,EAAAA,UAAU,EAAErD,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAACgI,IAAX,EAAiBhI,SAAS,CAAC4I,KAAV,CAAgB;AAC/DC,IAAAA,IAAI,EAAE7I,SAAS,CAACgI,IAD+C;AAE/Dc,IAAAA,KAAK,EAAE9I,SAAS,CAACgI,IAF8C;AAG/De,IAAAA,IAAI,EAAE/I,SAAS,CAACgI;AAH+C,GAAhB,CAAjB,CAApB,CAJY;AASxBgB,EAAAA,iBAAiB,EAAEhJ,SAAS,CAACkI,MATL;AAUxBe,EAAAA,cAAc,EAAEjJ,SAAS,CAAC4H,MAVF;AAWxBsB,EAAAA,kBAAkB,EAAElJ,SAAS,CAAC0H,MAXN;AAYxByB,EAAAA,UAAU,EAAEnJ,SAAS,CAACqI,KAAV,CAAgB,CAAC,MAAD,EAAS,SAAT,CAAhB,CAZY;AAaxBe,EAAAA,cAAc,EAAEpJ,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC0H,MAAX,EAAmB1H,SAAS,CAACkI,MAA7B,CAApB,CAbQ;AAcxBmB,EAAAA,UAAU,EAAErJ,SAAS,CAACqI,KAAV,CAAgB,CAAC,MAAD,EAAS,OAAT,EAAkB,SAAlB,CAAhB,CAdY;AAexBiB,EAAAA,gBAAgB,EAAEtJ,SAAS,CAACkI,MAfJ;AAgBxBqB,EAAAA,iBAAiB,EAAEvJ,SAAS,CAACkI,MAhBL;AAiBxBsB,EAAAA,MAAM,EAAExJ,SAAS,CAACgI,IAjBM;AAkBxByB,EAAAA,OAAO,EAAEzJ,SAAS,CAAC0H,MAlBK;AAmBxBgC,EAAAA,WAAW,EAAE1J,SAAS,CAAC2H;AAnBC,CAA1B;AAqBA,MAAMgC,yBAAyB,GAAG;AAChCC,EAAAA,WAAW,EAAE5J,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC4H,MAAX,EAAmB5H,SAAS,CAAC2H,IAA7B,CAApB,CADmB;AAEhCkC,EAAAA,YAAY,EAAE7J,SAAS,CAAC2H;AAFQ,CAAlC;AAIA,MAAMmC,gBAAgB,GAAG;AACvB7B,EAAAA,OAAO,EAAE,CADc;AAEvBE,EAAAA,OAAO,EAAE,CAFc;AAGvBC,EAAAA,KAAK,EAAE,OAHgB;AAIvBE,EAAAA,SAAS,EAAE,QAJY;AAKvBC,EAAAA,QAAQ,EAAE,MALa;AAMvB1C,EAAAA,QAAQ,EAAE;AANa,CAAzB;AAQA,MAAMkE,oBAAoB,GAAG,EAAE,GAAGD,gBAAL;AAC3BX,EAAAA,UAAU,EAAE,MADe;AAE3BE,EAAAA,UAAU,EAAE,SAFe;AAG3BL,EAAAA,iBAAiB,EAAE,GAHQ;AAI3BM,EAAAA,gBAAgB,EAAE,GAJS;AAK3BC,EAAAA,iBAAiB,EAAE;AALQ,CAA7B;;AAQA,MAAMS,YAAY,GAAG,CAACC,iBAAD,EAAoB3G,IAApB,KAA6B;AAChD,QAAM4G,YAAY,GAAGtG,UAAU,EAAE,aAAa1E,UAAU,CAAC,CAACqF,KAAD,EAAQ4F,GAAR,KAAgB;AACvE,WAAO,aAAapL,KAAK,CAACqL,aAAN,CAAoBH,iBAApB,EAAuC3I,MAAM,CAAC+I,MAAP,CAAc,EAAd,EAAkB9F,KAAlB,EAAyB;AAClF+F,MAAAA,WAAW,EAAEH,GADqE;AAElFI,MAAAA,UAAU,EAAEpL,UAAU,CAAC0B,iBAAD,CAAV,KAAkC0D,KAAK,CAAC8B;AAF8B,KAAzB,CAAvC,CAApB;AAID,GALuD,CAAzB,EAK3B/C,IAL2B,CAA/B;AAMA4G,EAAAA,YAAY,CAACM,WAAb,GAA4B,gBAAelH,IAAK,GAAhD;AACA,SAAO4G,YAAP;AACD,CATD;;AAWA,MAAMO,cAAc,GAAG,CAACF,UAAD,EAAajE,UAAb,EAAyB,GAAGoE,QAA5B,KAAyC;AAC9D,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBxL,QAAQ,CAAC,KAAD,CAApC;AACA,QAAMyL,UAAU,GAAG,CAACxJ,IAAI,CAACyJ,KAAN,EAAazJ,IAAI,CAAC0J,KAAlB,EAAyB,GAAGL,QAA5B,CAAnB;;AAEA,QAAMM,YAAY,GAAG,MAAML,MAAM,IAAIC,SAAS,CAAC,KAAD,CAA9C;;AAEA,SAAO;AACLK,IAAAA,QAAQ,EAAEN,MADL;AAELO,IAAAA,aAAa,EAAE,MAAM;AACnB,UAAI,CAAC5E,UAAL,EAAiBsE,SAAS,CAAC,IAAD,CAAT;AAClB,KAJI;AAKLO,IAAAA,WAAW,EAAEH,YALR;AAMLI,IAAAA,cAAc,EAAEJ,YANX;AAOLK,IAAAA,SAAS,EAAExG,CAAC,IAAI;AACd,UAAI,CAAC8F,MAAD,IAAWJ,UAAX,IAAyB,CAACjE,UAA1B,IAAwCuE,UAAU,CAACS,OAAX,CAAmBzG,CAAC,CAAChC,GAArB,MAA8B,CAAC,CAA3E,EAA8E;AAC5E+H,QAAAA,SAAS,CAAC,IAAD,CAAT;AACD;AACF,KAXI;AAYLW,IAAAA,OAAO,EAAE1G,CAAC,IAAI;AACZ,UAAIgG,UAAU,CAACS,OAAX,CAAmBzG,CAAC,CAAChC,GAArB,MAA8B,CAAC,CAAnC,EAAsC;AACpC+H,QAAAA,SAAS,CAAC,KAAD,CAAT;AACD;AACF,KAhBI;AAiBLY,IAAAA,MAAM,EAAE3G,CAAC,IAAI;AACX,UAAI8F,MAAM,IAAI,CAAC9F,CAAC,CAAC4G,aAAF,CAAgBC,QAAhB,CAAyB7G,CAAC,CAAC8G,aAA3B,CAAf,EAA0D;AACxDf,QAAAA,SAAS,CAAC,KAAD,CAAT;AACD;AACF;AArBI,GAAP;AAuBD,CA7BD;;AA+BA,MAAMgB,MAAM,GAAG,CAAC;AACdC,EAAAA,KADc;AAEdC,EAAAA,OAFc;AAGdC,EAAAA,SAHc;AAIdjE,EAAAA;AAJc,CAAD,KAKTzI,OAAO,CAAC,MAAM;AAClB,QAAM2M,YAAY,GAAGF,OAAO,GAAI,GAAED,KAAM,KAAIC,OAAQ,EAAxB,GAA4BD,KAAxD;AACA,MAAII,WAAW,GAAGD,YAAlB;;AAEA,OAAK,MAAM1I,IAAX,IAAmBhC,MAAM,CAACqB,IAAP,CAAYoJ,SAAS,IAAI,EAAzB,CAAnB,EAAiD;AAC/C,UAAMjI,KAAK,GAAGiI,SAAS,CAACzI,IAAD,CAAvB;;AAEA,QAAIQ,KAAJ,EAAW;AACTmI,MAAAA,WAAW,IAAK,IAAGD,YAAa,IAAhC;AACAC,MAAAA,WAAW,IAAInI,KAAK,KAAK,IAAV,GAAiBR,IAAjB,GAAyB,GAAEA,IAAK,IAAGQ,KAAM,EAAxD;AACD;AACF;;AAED,MAAIoI,iBAAiB,GAAG,OAAOpE,SAAP,KAAqB,UAArB,GAAkCA,SAAS,CAACiE,SAAD,CAA3C,GAAyDjE,SAAjF;;AAEA,MAAI,OAAOoE,iBAAP,KAA6B,QAAjC,EAA2C;AACzCA,IAAAA,iBAAiB,GAAGA,iBAAiB,CAAC7G,IAAlB,EAApB;AACA,QAAI6G,iBAAJ,EAAuBD,WAAW,IAAK,IAAGC,iBAAkB,EAArC;AACxB;;AAED,SAAOD,WAAP;AACD,CArBY,EAqBV,CAACJ,KAAD,EAAQC,OAAR,EAAiBC,SAAjB,EAA4BjE,SAA5B,CArBU,CALb;;AA4BA,MAAMqE,MAAM,GAAG,CAAChC,GAAD,EAAM2B,OAAN,KAAkB;AAC/B,MAAI,OAAO3B,GAAP,KAAe,UAAnB,EAA+B;AAC7BA,IAAAA,GAAG,CAAC2B,OAAD,CAAH;AACD,GAFD,MAEO,IAAI3B,GAAJ,EAAS;AACdA,IAAAA,GAAG,CAACiC,OAAJ,GAAcN,OAAd;AACD;AACF,CAND;;AAQA,MAAMO,cAAc,GAAG,CAACC,IAAD,EAAOC,IAAP,KAAgBlN,OAAO,CAAC,MAAM;AACnD,MAAI,CAACiN,IAAL,EAAW,OAAOC,IAAP;AACX,MAAI,CAACA,IAAL,EAAW,OAAOD,IAAP;AACX,SAAOR,OAAO,IAAI;AAChBK,IAAAA,MAAM,CAACG,IAAD,EAAOR,OAAP,CAAN;AACAK,IAAAA,MAAM,CAACI,IAAD,EAAOT,OAAP,CAAN;AACD,GAHD;AAID,CAP6C,EAO3C,CAACQ,IAAD,EAAOC,IAAP,CAP2C,CAA9C;;AASA,MAAMC,QAAQ,GAAG9J,GAAG,IAAIA,GAAG,IAAI,OAAOA,GAAP,KAAe,QAA9C;;AAEA,MAAM+J,WAAW,GAAG5J,GAAG,IAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,GAAiBA,GAAG,CAAC6J,KAAJ,CAAU,CAAV,CAAjB,GAAgC7J,GAA3D;;AAEA,MAAM8J,aAAa,GAAG,CAACC,MAAD,EAASb,SAAT,KAAuB1M,OAAO,CAAC,MAAM;AACzD,MAAI,OAAOuN,MAAP,KAAkB,UAAtB,EAAkC,OAAOA,MAAM,CAACb,SAAD,CAAb;AAClC,MAAI,CAACS,QAAQ,CAACI,MAAD,CAAb,EAAuB,OAAOrG,SAAP;AACvB,MAAI,CAACwF,SAAL,EAAgB,OAAOa,MAAP;AAChB,QAAMC,KAAK,GAAG,EAAd;;AAEA,OAAK,MAAMC,IAAX,IAAmBxL,MAAM,CAACqB,IAAP,CAAYiK,MAAZ,CAAnB,EAAwC;AACtC,UAAM9I,KAAK,GAAG8I,MAAM,CAACE,IAAD,CAApB;;AAEA,QAAIN,QAAQ,CAAC1I,KAAD,CAAZ,EAAqB;AACnB,YAAMiJ,aAAa,GAAGhB,SAAS,CAACU,WAAW,CAACK,IAAD,CAAZ,CAA/B;;AAEA,UAAI,OAAOC,aAAP,KAAyB,QAA7B,EAAuC;AACrC,aAAK,MAAMC,UAAX,IAAyB1L,MAAM,CAACqB,IAAP,CAAYmB,KAAZ,CAAzB,EAA6C;AAC3C,gBAAMmJ,WAAW,GAAGnJ,KAAK,CAACkJ,UAAD,CAAzB;;AAEA,cAAIR,QAAQ,CAACS,WAAD,CAAZ,EAA2B;AACzB,gBAAIR,WAAW,CAACO,UAAD,CAAX,KAA4BD,aAAhC,EAA+C;AAC7CzL,cAAAA,MAAM,CAAC+I,MAAP,CAAcwC,KAAd,EAAqBI,WAArB;AACD;AACF,WAJD,MAIO;AACLJ,YAAAA,KAAK,CAACG,UAAD,CAAL,GAAoBC,WAApB;AACD;AACF;AACF,OAZD,MAYO,IAAIF,aAAJ,EAAmB;AACxBzL,QAAAA,MAAM,CAAC+I,MAAP,CAAcwC,KAAd,EAAqB/I,KAArB;AACD;AACF,KAlBD,MAkBO;AACL+I,MAAAA,KAAK,CAACC,IAAD,CAAL,GAAchJ,KAAd;AACD;AACF;;AAED,SAAO+I,KAAP;AACD,CAjCmD,EAiCjD,CAACD,MAAD,EAASb,SAAT,CAjCiD,CAApD;;AAmCA,MAAMmB,yBAAyB,GAAG,OAAO/G,MAAP,KAAkB,WAAlB,IAAiC,OAAOA,MAAM,CAACR,QAAd,KAA2B,WAA5D,IAA2E,OAAOQ,MAAM,CAACR,QAAP,CAAgByE,aAAvB,KAAyC,WAApH,GAAkI9K,eAAlI,GAAoJC,SAAtL;;AAEA,MAAM4N,YAAY,GAAG,CAAChD,GAAD,EAAM9D,KAAN,EAAakE,UAAb,EAAyBjE,UAAzB,KAAwC;AAC3D,QAAM;AACJiD,IAAAA;AADI,MAEFpK,UAAU,CAACiC,mBAAD,CAFd;AAGA,QAAM;AACJgM,IAAAA,YADI;AAEJC,IAAAA,aAFI;AAGJC,IAAAA;AAHI,MAIFnO,UAAU,CAAC4B,mBAAD,CAJd;AAKA,QAAMwM,SAAS,GAAG/N,MAAM,EAAxB;;AAEA,QAAMgO,QAAQ,GAAG,MAAM;AACrB,QAAI,CAAClH,UAAL,EAAiBgH,QAAQ,CAAC;AACxBpG,MAAAA,IAAI,EAAE1F,qBAAqB,CAACiM,GADJ;AAExBpH,MAAAA;AAFwB,KAAD,CAAR;AAIlB,GALD;;AAOA,QAAMmF,MAAM,GAAG3G,CAAC,IAAI;AAClB,QAAI0F,UAAU,IAAI,CAAC1F,CAAC,CAAC4G,aAAF,CAAgBC,QAAhB,CAAyB7G,CAAC,CAAC8G,aAA3B,CAAnB,EAA8D;AAC5D2B,MAAAA,QAAQ,CAAC;AACPpG,QAAAA,IAAI,EAAE1F,qBAAqB,CAACkM,KADrB;AAEPrH,QAAAA;AAFO,OAAD,CAAR;AAID;AACF,GAPD;;AASA,QAAMsH,YAAY,GAAG,MAAM;AACzB,QAAIN,aAAJ,EAAmB;AACjBE,MAAAA,SAAS,CAACnB,OAAV,GAAoBwB,UAAU,CAACJ,QAAD,EAAWjE,iBAAX,CAA9B;AACD,KAFD,MAEO;AACLiE,MAAAA,QAAQ;AACT;AACF,GAND;;AAQA,QAAMK,YAAY,GAAG,CAACC,CAAD,EAAIC,SAAJ,KAAkB;AACrCR,IAAAA,SAAS,CAACnB,OAAV,IAAqB4B,YAAY,CAACT,SAAS,CAACnB,OAAX,CAAjC;AACA,QAAI,CAAC2B,SAAL,EAAgBT,QAAQ,CAAC;AACvBpG,MAAAA,IAAI,EAAE1F,qBAAqB,CAACkM,KADL;AAEvBrH,MAAAA;AAFuB,KAAD,CAAR;AAIjB,GAND;;AAQA9G,EAAAA,SAAS,CAAC,MAAM,MAAMyO,YAAY,CAACT,SAAS,CAACnB,OAAX,CAAzB,EAA8C,EAA9C,CAAT;AACA7M,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIgL,UAAU,IAAI6C,YAAlB,EAAgC;AAC9BjD,MAAAA,GAAG,CAACiC,OAAJ,IAAejC,GAAG,CAACiC,OAAJ,CAAY6B,KAAZ,EAAf;AACD;AACF,GAJQ,EAIN,CAAC9D,GAAD,EAAMI,UAAN,EAAkB6C,YAAlB,CAJM,CAAT;AAKA,SAAO;AACLI,IAAAA,QADK;AAELhC,IAAAA,MAFK;AAGLmC,IAAAA,YAHK;AAILE,IAAAA;AAJK,GAAP;AAMD,CAvDD;;AAyDA,MAAMK,aAAa,GAAG,CAACrE,YAAD,EAAesE,MAAf,KAA0B;AAC9C,QAAMC,QAAQ,GAAG5O,MAAM,CAAC2O,MAAD,CAAvB;AACA5O,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI6O,QAAQ,CAAChC,OAAT,KAAqB+B,MAAzB,EAAiC5K,QAAQ,CAACsG,YAAD,EAAe;AACtDhB,MAAAA,IAAI,EAAEsF;AADgD,KAAf,CAAR;AAGjCC,IAAAA,QAAQ,CAAChC,OAAT,GAAmB+B,MAAnB;AACD,GALQ,EAKN,CAACtE,YAAD,EAAesE,MAAf,CALM,CAAT;AAMD,CARD;;AAUA,MAAME,YAAY,GAAG,CAAC;AACpB3F,EAAAA,cADoB;AAEpBC,EAAAA,cAFoB;AAGpBtF,EAAAA,UAHoB;AAIpB2F,EAAAA;AAJoB,IAKlB,EALiB,KAKV;AACT,QAAM,CAAC1G,KAAD,EAAQgM,UAAR,EAAoBC,aAApB,IAAqCtO,aAAa,CAAC;AACvDuO,IAAAA,YAAY,EAAE,CAAC9F,cADwC;AAEvD+F,IAAAA,aAAa,EAAE9F,cAFwC;AAGvD+F,IAAAA,OAAO,EAAE1F,iBAH8C;AAIvD2F,IAAAA,KAAK,EAAEvL,aAAa,CAACC,UAAD,EAAa,MAAb,CAJmC;AAKvDuL,IAAAA,IAAI,EAAExL,aAAa,CAACC,UAAD,EAAa,OAAb;AALoC,GAAD,CAAxD;AAOA,SAAO;AACLf,IAAAA,KAAK,EAAEV,YAAY,CAACU,KAAD,CADd;AAELgM,IAAAA,UAFK;AAGLC,IAAAA;AAHK,GAAP;AAKD,CAlBD;;AAoBA,MAAMM,oBAAoB,GAAGC,OAAO,IAAI;AACtC,QAAMC,SAAS,GAAGV,YAAY,CAACS,OAAD,CAA9B;AACA,QAAM,CAACE,aAAD,EAAgBC,gBAAhB,IAAoC7P,QAAQ,CAAC,EAAD,CAAlD;;AAEA,QAAM8P,QAAQ,GAAG,CAAC3G,QAAD,EAAW4G,YAAX,KAA4B;AAC3CF,IAAAA,gBAAgB,CAAC;AACf1G,MAAAA,QADe;AAEf4G,MAAAA;AAFe,KAAD,CAAhB;AAIAJ,IAAAA,SAAS,CAACT,UAAV,CAAqB,IAArB;AACD,GAND;;AAQA,SAAO,EAAE,GAAGS,SAAL;AACLG,IAAAA,QADK;AAELF,IAAAA;AAFK,GAAP;AAID,CAhBD;;AAkBA,MAAMI,UAAU,GAAGxL,UAAU,EAAE,aAAa1E,UAAU,CAAC,SAASkQ,UAAT,CAAoB;AACzEtH,EAAAA,SADyE;AAEzE8E,EAAAA,MAFyE;AAGzEuB,EAAAA,MAHyE;AAIzEhH,EAAAA,QAJyE;AAKzEP,EAAAA,QALyE;AAMzE,KAAGyI;AANsE,CAApB,EAOpDlF,GAPoD,EAO/C;AACN,QAAM4B,SAAS,GAAG1M,OAAO,CAAC,MAAMiC,MAAM,CAACC,MAAP,CAAc;AAC5CsH,IAAAA,IAAI,EAAEsF;AADsC,GAAd,CAAP,EAErB,CAACA,MAAD,CAFqB,CAAzB;AAGA,SAAO,aAAapP,KAAK,CAACqL,aAAN,CAAoB,QAApB,EAA8B9I,MAAM,CAAC+I,MAAP,CAAc;AAC9D,qBAAiB,IAD6C;AAE9D,qBAAiB8D,MAF6C;AAG9D,qBAAiBhH,QAAQ,IAAIZ,SAHiC;AAI9DW,IAAAA,IAAI,EAAE,QAJwD;AAK9DC,IAAAA,QAAQ,EAAEA;AALoD,GAAd,EAM/CkI,SAN+C,EAMpC;AACZlF,IAAAA,GAAG,EAAEA,GADO;AAEZrC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAEzL,eADS;AAEhB2L,MAAAA,SAFgB;AAGhBjE,MAAAA;AAHgB,KAAD,CAFL;AAOZ+E,IAAAA,KAAK,EAAEF,aAAa,CAACC,MAAD,EAASb,SAAT;AAPR,GANoC,CAA9B,EAchBnF,QAdgB,CAApB;AAeD,CA1BqD,CAAzB,EA0BzB,YA1ByB,CAA7B;AA2BAwI,UAAU,CAACE,SAAX,GAAuB,EAAE,GAAG9H,cAAc,EAAnB;AACrB2G,EAAAA,MAAM,EAAEnO,SAAS,CAACgI,IADG;AAErBb,EAAAA,QAAQ,EAAEnH,SAAS,CAACgI;AAFC,CAAvB;;AAKA,MAAMuH,kBAAkB,GAAG,CAAC;AAC1BC,EAAAA,OAD0B;AAE1BC,EAAAA,YAF0B;AAG1BC,EAAAA,YAH0B;AAI1BxG,EAAAA;AAJ0B,CAAD,KAKrB;AACJ,QAAMyG,QAAQ,GAAGH,OAAO,CAACpD,OAAR,CAAgBwD,qBAAhB,EAAjB;AACA,QAAMC,aAAa,GAAGJ,YAAY,CAACrD,OAAb,CAAqBwD,qBAArB,EAAtB;AACA,QAAME,YAAY,GAAGJ,YAAY,CAACtD,OAAb,KAAyBjG,MAAzB,GAAkC;AACrDhB,IAAAA,IAAI,EAAE,CAD+C;AAErDH,IAAAA,GAAG,EAAE,CAFgD;AAGrDC,IAAAA,KAAK,EAAEU,QAAQ,CAACoK,eAAT,CAAyBC,WAHqB;AAIrD9K,IAAAA,MAAM,EAAEiB,MAAM,CAAC8J;AAJsC,GAAlC,GAKjBP,YAAY,CAACtD,OAAb,CAAqBwD,qBAArB,EALJ;AAMA,QAAMxK,OAAO,GAAGN,YAAY,CAACoE,kBAAD,CAA5B;;AAEA,QAAMgH,eAAe,GAAGC,CAAC,IAAIA,CAAC,GAAGN,aAAa,CAAC1K,IAAlB,GAAyB2K,YAAY,CAAC3K,IAAtC,GAA6CC,OAAO,CAACD,IAAlF;;AAEA,QAAMiL,gBAAgB,GAAGD,CAAC,IAAIA,CAAC,GAAGN,aAAa,CAAC1K,IAAlB,GAAyBwK,QAAQ,CAACU,KAAlC,GAA0CP,YAAY,CAAC7K,KAAvD,GAA+DG,OAAO,CAACH,KAArG;;AAEA,QAAMqL,cAAc,GAAGC,CAAC,IAAIA,CAAC,GAAGV,aAAa,CAAC7K,GAAlB,GAAwB8K,YAAY,CAAC9K,GAArC,GAA2CI,OAAO,CAACJ,GAA/E;;AAEA,QAAMwL,iBAAiB,GAAGD,CAAC,IAAIA,CAAC,GAAGV,aAAa,CAAC7K,GAAlB,GAAwB2K,QAAQ,CAACc,MAAjC,GAA0CX,YAAY,CAAC5K,MAAvD,GAAgEE,OAAO,CAACF,MAAvG;;AAEA,QAAMwL,mBAAmB,GAAGP,CAAC,IAAI;AAC/B,QAAIQ,YAAY,GAAGT,eAAe,CAACC,CAAD,CAAlC;;AAEA,QAAIQ,YAAY,GAAG,CAAnB,EAAsB;AACpBR,MAAAA,CAAC,IAAIQ,YAAL;AACD,KAFD,MAEO;AACL,YAAMC,aAAa,GAAGR,gBAAgB,CAACD,CAAD,CAAtC;;AAEA,UAAIS,aAAa,GAAG,CAApB,EAAuB;AACrBT,QAAAA,CAAC,IAAIS,aAAL;AACAD,QAAAA,YAAY,GAAGT,eAAe,CAACC,CAAD,CAA9B;AACA,YAAIQ,YAAY,GAAG,CAAnB,EAAsBR,CAAC,IAAIQ,YAAL;AACvB;AACF;;AAED,WAAOR,CAAP;AACD,GAhBD;;AAkBA,QAAMU,iBAAiB,GAAGN,CAAC,IAAI;AAC7B,QAAIO,WAAW,GAAGR,cAAc,CAACC,CAAD,CAAhC;;AAEA,QAAIO,WAAW,GAAG,CAAlB,EAAqB;AACnBP,MAAAA,CAAC,IAAIO,WAAL;AACD,KAFD,MAEO;AACL,YAAMC,cAAc,GAAGP,iBAAiB,CAACD,CAAD,CAAxC;;AAEA,UAAIQ,cAAc,GAAG,CAArB,EAAwB;AACtBR,QAAAA,CAAC,IAAIQ,cAAL;AACAD,QAAAA,WAAW,GAAGR,cAAc,CAACC,CAAD,CAA5B;AACA,YAAIO,WAAW,GAAG,CAAlB,EAAqBP,CAAC,IAAIO,WAAL;AACtB;AACF;;AAED,WAAOP,CAAP;AACD,GAhBD;;AAkBA,SAAO;AACLZ,IAAAA,QADK;AAELE,IAAAA,aAFK;AAGLK,IAAAA,eAHK;AAILE,IAAAA,gBAJK;AAKLE,IAAAA,cALK;AAMLE,IAAAA,iBANK;AAOLE,IAAAA,mBAPK;AAQLG,IAAAA;AARK,GAAP;AAUD,CAtED;;AAwEA,MAAMG,mBAAmB,GAAG,CAAC;AAC3BC,EAAAA,eAD2B;AAE3BC,EAAAA;AAF2B,CAAD,KAGtB;AACJ,QAAM;AACJvB,IAAAA,QADI;AAEJE,IAAAA,aAFI;AAGJK,IAAAA,eAHI;AAIJE,IAAAA,gBAJI;AAKJE,IAAAA,cALI;AAMJE,IAAAA,iBANI;AAOJE,IAAAA,mBAPI;AAQJG,IAAAA;AARI,MASFI,eATJ;AAUA,MAAId,CAAJ,EAAOI,CAAP;AACAJ,EAAAA,CAAC,GAAGe,WAAW,CAACf,CAAZ,GAAgBN,aAAa,CAAC1K,IAAlC;AACAoL,EAAAA,CAAC,GAAGW,WAAW,CAACX,CAAZ,GAAgBV,aAAa,CAAC7K,GAAlC;AACA,QAAM4L,aAAa,GAAGR,gBAAgB,CAACD,CAAD,CAAtC;;AAEA,MAAIS,aAAa,GAAG,CAApB,EAAuB;AACrB,UAAMO,SAAS,GAAGhB,CAAC,GAAGR,QAAQ,CAACU,KAA/B;AACA,UAAMM,YAAY,GAAGT,eAAe,CAACiB,SAAD,CAApC;;AAEA,QAAIR,YAAY,IAAI,CAAhB,IAAqB,CAACA,YAAD,GAAgBC,aAAzC,EAAwD;AACtDT,MAAAA,CAAC,GAAGgB,SAAJ;AACD;;AAEDhB,IAAAA,CAAC,GAAGO,mBAAmB,CAACP,CAAD,CAAvB;AACD;;AAED,MAAIiB,iBAAiB,GAAG,QAAxB;AACA,QAAML,cAAc,GAAGP,iBAAiB,CAACD,CAAD,CAAxC;;AAEA,MAAIQ,cAAc,GAAG,CAArB,EAAwB;AACtB,UAAMM,SAAS,GAAGd,CAAC,GAAGZ,QAAQ,CAACc,MAA/B;AACA,UAAMK,WAAW,GAAGR,cAAc,CAACe,SAAD,CAAlC;;AAEA,QAAIP,WAAW,IAAI,CAAf,IAAoB,CAACA,WAAD,GAAeC,cAAvC,EAAuD;AACrDR,MAAAA,CAAC,GAAGc,SAAJ;AACAD,MAAAA,iBAAiB,GAAG,KAApB;AACD;;AAEDb,IAAAA,CAAC,GAAGM,iBAAiB,CAACN,CAAD,CAArB;AACD;;AAED,SAAO;AACLJ,IAAAA,CADK;AAELI,IAAAA,CAFK;AAGLa,IAAAA;AAHK,GAAP;AAKD,CAlDD;;AAoDA,MAAME,kBAAkB,GAAG,CAAC;AAC1BC,EAAAA,QAD0B;AAE1BC,EAAAA,KAF0B;AAG1BC,EAAAA,UAH0B;AAI1B5B,EAAAA,aAJ0B;AAK1BF,EAAAA;AAL0B,CAAD,KAMrB;AACJ,MAAIY,CAAC,GAAGkB,UAAU,CAACzM,GAAX,GAAiB6K,aAAa,CAAC7K,GAA/B,GAAqCwM,KAArC,GAA6CC,UAAU,CAAChB,MAAX,GAAoB,CAAzE;AACA,QAAMiB,MAAM,GAAGH,QAAQ,CAACnF,OAAT,CAAiBuF,YAAjB,GAAgC,IAA/C;AACApB,EAAAA,CAAC,GAAGrN,IAAI,CAAC0O,GAAL,CAASF,MAAT,EAAiBnB,CAAjB,CAAJ;AACAA,EAAAA,CAAC,GAAGrN,IAAI,CAAC2O,GAAL,CAAStB,CAAT,EAAYZ,QAAQ,CAACc,MAAT,GAAkBiB,MAA9B,CAAJ;AACA,SAAOnB,CAAP;AACD,CAZD;;AAcA,MAAMuB,gBAAgB,GAAG,CAAC;AACxBL,EAAAA,UADwB;AAExB5B,EAAAA,aAFwB;AAGxBF,EAAAA,QAHwB;AAIxBoC,EAAAA,iBAJwB;AAKxBC,EAAAA,UALwB;AAMxBC,EAAAA,WANwB;AAOxB/B,EAAAA,eAPwB;AAQxBE,EAAAA,gBARwB;AASxBM,EAAAA,mBATwB;AAUxBG,EAAAA,iBAVwB;AAWxBU,EAAAA,QAXwB;AAYxBxJ,EAAAA,KAZwB;AAaxBO,EAAAA,SAbwB;AAcxBC,EAAAA;AAdwB,CAAD,KAenB;AACJ,MAAI6I,iBAAiB,GAAG9I,SAAxB;AACA,MAAIiI,CAAC,GAAGwB,iBAAR;;AAEA,MAAIxJ,QAAQ,KAAK,SAAjB,EAA4B;AAC1BgI,IAAAA,CAAC,GAAGM,iBAAiB,CAACN,CAAD,CAArB;;AAEA,QAAIhI,QAAQ,KAAK,QAAjB,EAA2B;AACzBgI,MAAAA,CAAC,GAAGrN,IAAI,CAAC2O,GAAL,CAAStB,CAAT,EAAYkB,UAAU,CAACvM,MAAX,GAAoB2K,aAAa,CAAC7K,GAA9C,CAAJ;AACAuL,MAAAA,CAAC,GAAGrN,IAAI,CAAC0O,GAAL,CAASrB,CAAT,EAAYkB,UAAU,CAACzM,GAAX,GAAiB6K,aAAa,CAAC7K,GAA/B,GAAqC2K,QAAQ,CAACc,MAA1D,CAAJ;AACD;AACF;;AAED,MAAIN,CAAJ,EAAOQ,YAAP,EAAqBC,aAArB;;AAEA,MAAIQ,iBAAiB,KAAK,MAA1B,EAAkC;AAChCjB,IAAAA,CAAC,GAAG6B,UAAJ;;AAEA,QAAIzJ,QAAQ,KAAK,SAAjB,EAA4B;AAC1BoI,MAAAA,YAAY,GAAGT,eAAe,CAACC,CAAD,CAA9B;;AAEA,UAAIQ,YAAY,GAAG,CAAnB,EAAsB;AACpBC,QAAAA,aAAa,GAAGR,gBAAgB,CAAC6B,WAAD,CAAhC;;AAEA,YAAIrB,aAAa,IAAI,CAAjB,IAAsB,CAACD,YAAD,GAAgBC,aAA1C,EAAyD;AACvDT,UAAAA,CAAC,GAAG8B,WAAJ;AACAb,UAAAA,iBAAiB,GAAG,OAApB;AACD;AACF;AACF;AACF,GAfD,MAeO;AACLjB,IAAAA,CAAC,GAAG8B,WAAJ;;AAEA,QAAI1J,QAAQ,KAAK,SAAjB,EAA4B;AAC1BqI,MAAAA,aAAa,GAAGR,gBAAgB,CAACD,CAAD,CAAhC;;AAEA,UAAIS,aAAa,GAAG,CAApB,EAAuB;AACrBD,QAAAA,YAAY,GAAGT,eAAe,CAAC8B,UAAD,CAA9B;;AAEA,YAAIrB,YAAY,IAAI,CAAhB,IAAqB,CAACA,YAAD,GAAgBC,aAAzC,EAAwD;AACtDT,UAAAA,CAAC,GAAG6B,UAAJ;AACAZ,UAAAA,iBAAiB,GAAG,MAApB;AACD;AACF;AACF;AACF;;AAED,MAAI7I,QAAQ,KAAK,MAAjB,EAAyB4H,CAAC,GAAGO,mBAAmB,CAACP,CAAD,CAAvB;AACzB,QAAM+B,MAAM,GAAGnK,KAAK,GAAGuJ,kBAAkB,CAAC;AACxCE,IAAAA,KAAK,EAAEjB,CADiC;AAExCgB,IAAAA,QAFwC;AAGxCE,IAAAA,UAHwC;AAIxC5B,IAAAA,aAJwC;AAKxCF,IAAAA;AALwC,GAAD,CAArB,GAMfpJ,SANL;AAOA,SAAO;AACL2L,IAAAA,MADK;AAEL/B,IAAAA,CAFK;AAGLI,IAAAA,CAHK;AAILa,IAAAA;AAJK,GAAP;AAMD,CA5ED;;AA8EA,MAAMe,oBAAoB,GAAG,CAAC;AAC5BZ,EAAAA,QAD4B;AAE5Ba,EAAAA,KAF4B;AAG5BX,EAAAA,UAH4B;AAI5B5B,EAAAA,aAJ4B;AAK5BF,EAAAA;AAL4B,CAAD,KAMvB;AACJ,MAAIQ,CAAC,GAAGsB,UAAU,CAACtM,IAAX,GAAkB0K,aAAa,CAAC1K,IAAhC,GAAuCiN,KAAvC,GAA+CX,UAAU,CAACpB,KAAX,GAAmB,CAA1E;AACA,QAAMqB,MAAM,GAAGH,QAAQ,CAACnF,OAAT,CAAiBiG,WAAjB,GAA+B,IAA9C;AACAlC,EAAAA,CAAC,GAAGjN,IAAI,CAAC0O,GAAL,CAASF,MAAT,EAAiBvB,CAAjB,CAAJ;AACAA,EAAAA,CAAC,GAAGjN,IAAI,CAAC2O,GAAL,CAAS1B,CAAT,EAAYR,QAAQ,CAACU,KAAT,GAAiBqB,MAA7B,CAAJ;AACA,SAAOvB,CAAP;AACD,CAZD;;AAcA,MAAMmC,gBAAgB,GAAG,CAAC;AACxBb,EAAAA,UADwB;AAExB5B,EAAAA,aAFwB;AAGxBF,EAAAA,QAHwB;AAIxB4C,EAAAA,iBAJwB;AAKxBC,EAAAA,SALwB;AAMxBC,EAAAA,YANwB;AAOxBnC,EAAAA,cAPwB;AAQxBE,EAAAA,iBARwB;AASxBE,EAAAA,mBATwB;AAUxBG,EAAAA,iBAVwB;AAWxBU,EAAAA,QAXwB;AAYxBxJ,EAAAA,KAZwB;AAaxBO,EAAAA,SAbwB;AAcxBC,EAAAA;AAdwB,CAAD,KAenB;AACJ,MAAI6I,iBAAiB,GAAG9I,SAAS,KAAK,KAAd,GAAsB,KAAtB,GAA8B,QAAtD;AACA,MAAI6H,CAAC,GAAGoC,iBAAR;;AAEA,MAAIhK,QAAQ,KAAK,SAAjB,EAA4B;AAC1B4H,IAAAA,CAAC,GAAGO,mBAAmB,CAACP,CAAD,CAAvB;;AAEA,QAAI5H,QAAQ,KAAK,QAAjB,EAA2B;AACzB4H,MAAAA,CAAC,GAAGjN,IAAI,CAAC2O,GAAL,CAAS1B,CAAT,EAAYsB,UAAU,CAACxM,KAAX,GAAmB4K,aAAa,CAAC1K,IAA7C,CAAJ;AACAgL,MAAAA,CAAC,GAAGjN,IAAI,CAAC0O,GAAL,CAASzB,CAAT,EAAYsB,UAAU,CAACtM,IAAX,GAAkB0K,aAAa,CAAC1K,IAAhC,GAAuCwK,QAAQ,CAACU,KAA5D,CAAJ;AACD;AACF;;AAED,MAAIE,CAAJ,EAAOO,WAAP,EAAoBC,cAApB;;AAEA,MAAIK,iBAAiB,KAAK,KAA1B,EAAiC;AAC/Bb,IAAAA,CAAC,GAAGiC,SAAJ;;AAEA,QAAIjK,QAAQ,KAAK,SAAjB,EAA4B;AAC1BuI,MAAAA,WAAW,GAAGR,cAAc,CAACC,CAAD,CAA5B;;AAEA,UAAIO,WAAW,GAAG,CAAlB,EAAqB;AACnBC,QAAAA,cAAc,GAAGP,iBAAiB,CAACiC,YAAD,CAAlC;;AAEA,YAAI1B,cAAc,IAAI,CAAlB,IAAuB,CAACD,WAAD,GAAeC,cAA1C,EAA0D;AACxDR,UAAAA,CAAC,GAAGkC,YAAJ;AACArB,UAAAA,iBAAiB,GAAG,QAApB;AACD;AACF;AACF;AACF,GAfD,MAeO;AACLb,IAAAA,CAAC,GAAGkC,YAAJ;;AAEA,QAAIlK,QAAQ,KAAK,SAAjB,EAA4B;AAC1BwI,MAAAA,cAAc,GAAGP,iBAAiB,CAACD,CAAD,CAAlC;;AAEA,UAAIQ,cAAc,GAAG,CAArB,EAAwB;AACtBD,QAAAA,WAAW,GAAGR,cAAc,CAACkC,SAAD,CAA5B;;AAEA,YAAI1B,WAAW,IAAI,CAAf,IAAoB,CAACA,WAAD,GAAeC,cAAvC,EAAuD;AACrDR,UAAAA,CAAC,GAAGiC,SAAJ;AACApB,UAAAA,iBAAiB,GAAG,KAApB;AACD;AACF;AACF;AACF;;AAED,MAAI7I,QAAQ,KAAK,MAAjB,EAAyBgI,CAAC,GAAGM,iBAAiB,CAACN,CAAD,CAArB;AACzB,QAAMmC,MAAM,GAAG3K,KAAK,GAAGoK,oBAAoB,CAAC;AAC1CC,IAAAA,KAAK,EAAEjC,CADmC;AAE1CoB,IAAAA,QAF0C;AAG1CE,IAAAA,UAH0C;AAI1C5B,IAAAA,aAJ0C;AAK1CF,IAAAA;AAL0C,GAAD,CAAvB,GAMfpJ,SANL;AAOA,SAAO;AACLmM,IAAAA,MADK;AAELvC,IAAAA,CAFK;AAGLI,IAAAA,CAHK;AAILa,IAAAA;AAJK,GAAP;AAMD,CA5ED;;AA8EA,MAAMuB,YAAY,GAAG,CAAC;AACpB5K,EAAAA,KADoB;AAEpBK,EAAAA,KAFoB;AAGpBE,EAAAA,SAHoB;AAIpBL,EAAAA,OAJoB;AAKpBE,EAAAA,OALoB;AAMpBI,EAAAA,QANoB;AAOpBqK,EAAAA,SAPoB;AAQpBrB,EAAAA,QARoB;AASpBN,EAAAA;AAToB,CAAD,KAUf;AACJ,QAAM;AACJtB,IAAAA,QADI;AAEJE,IAAAA;AAFI,MAGFoB,eAHJ;AAIA,MAAI4B,gBAAgB,GAAG5K,OAAvB;AACA,MAAI6K,cAAc,GAAG3K,OAArB;;AAEA,MAAIJ,KAAJ,EAAW;AACT,QAAIO,SAAS,KAAK,MAAd,IAAwBA,SAAS,KAAK,OAA1C,EAAmD;AACjDuK,MAAAA,gBAAgB,IAAItB,QAAQ,CAACnF,OAAT,CAAiBiG,WAArC;AACD,KAFD,MAEO;AACLS,MAAAA,cAAc,IAAIvB,QAAQ,CAACnF,OAAT,CAAiBuF,YAAnC;AACD;AACF;;AAED,QAAMF,UAAU,GAAGmB,SAAS,CAACxG,OAAV,CAAkBwD,qBAAlB,EAAnB;AACA,QAAMoC,UAAU,GAAGP,UAAU,CAACtM,IAAX,GAAkB0K,aAAa,CAAC1K,IAAhC,GAAuCwK,QAAQ,CAACU,KAAhD,GAAwDwC,gBAA3E;AACA,QAAMZ,WAAW,GAAGR,UAAU,CAACxM,KAAX,GAAmB4K,aAAa,CAAC1K,IAAjC,GAAwC0N,gBAA5D;AACA,QAAML,SAAS,GAAGf,UAAU,CAACzM,GAAX,GAAiB6K,aAAa,CAAC7K,GAA/B,GAAqC2K,QAAQ,CAACc,MAA9C,GAAuDqC,cAAzE;AACA,QAAML,YAAY,GAAGhB,UAAU,CAACvM,MAAX,GAAoB2K,aAAa,CAAC7K,GAAlC,GAAwC8N,cAA7D;AACA,MAAIP,iBAAJ,EAAuBR,iBAAvB;;AAEA,MAAI3J,KAAK,KAAK,KAAd,EAAqB;AACnBmK,IAAAA,iBAAiB,GAAGd,UAAU,CAACxM,KAAX,GAAmB4K,aAAa,CAAC1K,IAAjC,GAAwCwK,QAAQ,CAACU,KAArE;AACA0B,IAAAA,iBAAiB,GAAGN,UAAU,CAACvM,MAAX,GAAoB2K,aAAa,CAAC7K,GAAlC,GAAwC2K,QAAQ,CAACc,MAArE;AACD,GAHD,MAGO,IAAIrI,KAAK,KAAK,QAAd,EAAwB;AAC7BmK,IAAAA,iBAAiB,GAAGd,UAAU,CAACtM,IAAX,GAAkB0K,aAAa,CAAC1K,IAAhC,GAAuC,CAACwK,QAAQ,CAACU,KAAT,GAAiBoB,UAAU,CAACpB,KAA7B,IAAsC,CAAjG;AACA0B,IAAAA,iBAAiB,GAAGN,UAAU,CAACzM,GAAX,GAAiB6K,aAAa,CAAC7K,GAA/B,GAAqC,CAAC2K,QAAQ,CAACc,MAAT,GAAkBgB,UAAU,CAAChB,MAA9B,IAAwC,CAAjG;AACD,GAHM,MAGA;AACL8B,IAAAA,iBAAiB,GAAGd,UAAU,CAACtM,IAAX,GAAkB0K,aAAa,CAAC1K,IAApD;AACA4M,IAAAA,iBAAiB,GAAGN,UAAU,CAACzM,GAAX,GAAiB6K,aAAa,CAAC7K,GAAnD;AACD;;AAEDuN,EAAAA,iBAAiB,IAAIM,gBAArB;AACAd,EAAAA,iBAAiB,IAAIe,cAArB;AACA,QAAMhE,OAAO,GAAG,EAAE,GAAGmC,eAAL;AACdQ,IAAAA,UADc;AAEdO,IAAAA,UAFc;AAGdC,IAAAA,WAHc;AAIdF,IAAAA,iBAJc;AAKdS,IAAAA,SALc;AAMdC,IAAAA,YANc;AAOdF,IAAAA,iBAPc;AAQdhB,IAAAA,QARc;AASdxJ,IAAAA,KATc;AAUdO,IAAAA,SAVc;AAWdC,IAAAA;AAXc,GAAhB;;AAcA,UAAQD,SAAR;AACE,SAAK,MAAL;AACA,SAAK,OAAL;AACE,aAAOwJ,gBAAgB,CAAChD,OAAD,CAAvB;;AAEF,SAAK,KAAL;AACA,SAAK,QAAL;AACA;AACE,aAAOwD,gBAAgB,CAACxD,OAAD,CAAvB;AARJ;AAUD,CAtED;;AAwEA,MAAMiE,QAAQ,GAAG,CAAC;AAChBC,EAAAA,SADgB;AAEhBC,EAAAA,aAFgB;AAGhBC,EAAAA,UAHgB;AAIhBC,EAAAA,cAJgB;AAKhBC,EAAAA,WALgB;AAMhBlC,EAAAA,WANgB;AAOhB0B,EAAAA,SAPgB;AAQhBnD,EAAAA,YARgB;AAShBnF,EAAAA,WATgB;AAUhB+I,EAAAA,kBAVgB;AAWhBtL,EAAAA,KAXgB;AAYhBK,EAAAA,KAZgB;AAahBE,EAAAA,SAbgB;AAchBC,EAAAA,QAdgB;AAehB1C,EAAAA,QAfgB;AAgBhBuD,EAAAA,cAhBgB;AAiBhBkK,EAAAA,YAAY,EAAEC,aAAa,GAAG,IAjBd;AAkBhBjR,EAAAA,KAAK,EAAEyM,SAlBS;AAmBhBR,EAAAA,aAnBgB;AAoBhBjI,EAAAA,UApBgB;AAqBhB0I,EAAAA,aArBgB;AAsBhB/G,EAAAA,OAtBgB;AAuBhBE,EAAAA,OAvBgB;AAwBhBvB,EAAAA,QAxBgB;AAyBhB4M,EAAAA,OAzBgB;AA0BhB,KAAGnE;AA1Ba,CAAD,KA2BX;AACJ,QAAMlB,MAAM,GAAG9L,UAAU,CAAC0M,SAAD,CAAzB;AACA,QAAM,CAAC0E,YAAD,EAAeC,eAAf,IAAkCtU,QAAQ,CAAC;AAC/C+Q,IAAAA,CAAC,EAAE,CAD4C;AAE/CI,IAAAA,CAAC,EAAE;AAF4C,GAAD,CAAhD;AAIA,QAAM,CAACoD,aAAD,EAAgBC,gBAAhB,IAAoCxU,QAAQ,CAAC,EAAD,CAAlD;AACA,QAAM,CAACyU,YAAD,EAAeC,eAAf,IAAkC1U,QAAQ,EAAhD;AACA,QAAM,CAAC2U,iBAAD,EAAoBC,oBAApB,IAA4C5U,QAAQ,CAACkJ,SAAD,CAA1D;AACA,QAAM;AACJjF,IAAAA,UADI;AAEJ4F,IAAAA,cAFI;AAGJC,IAAAA,kBAHI;AAIJ+K,IAAAA,WAJI;AAKJC,IAAAA,aALI;AAMJxE,IAAAA,YANI;AAOJyE,IAAAA,kBAPI;AAQJhL,IAAAA,UARI;AASJE,IAAAA;AATI,MAUFlK,UAAU,CAACgC,eAAD,CAVd;AAWA,QAAMqO,OAAO,GAAGhQ,MAAM,CAAC,IAAD,CAAtB;AACA,QAAM+R,QAAQ,GAAG/R,MAAM,CAAC,IAAD,CAAvB;AACA,QAAM4U,cAAc,GAAG5U,MAAM,CAAC,CAAD,CAA7B;AACA,QAAM4O,QAAQ,GAAG5O,MAAM,CAAC2O,MAAD,CAAvB;AACA,QAAMkG,cAAc,GAAG7U,MAAM,CAAC;AAC5B6Q,IAAAA,KAAK,EAAE,CADqB;AAE5BI,IAAAA,MAAM,EAAE;AAFoB,GAAD,CAA7B;AAIA,QAAM6D,oBAAoB,GAAG9U,MAAM,CAAC,MAAM,CAAE,CAAT,CAAnC;AACA,QAAM+U,kBAAkB,GAAG/U,MAAM,CAAC,KAAD,CAAjC;AACA,QAAMgV,SAAS,GAAGrV,UAAU,CAAC6B,eAAD,CAAV,CAA4ByT,YAA5B,IAA4CrL,cAA9D;AACA,QAAM,CAACqL,YAAD,EAAeC,iBAAf,IAAoCjV,UAAU,CAACkV,CAAC,IAAIA,CAAC,GAAG,CAAV,EAAa,CAAb,CAApD;AACA,QAAM,CAAC;AACLC,IAAAA,UADK;AAELC,IAAAA;AAFK,GAAD,EAGHvH,QAHG,IAGS7N,UAAU,CAACqV,OAAD,EAAU;AACjCF,IAAAA,UAAU,EAAEhU,iBADqB;AAEjCiU,IAAAA,gBAAgB,EAAE;AAFe,GAAV,CAHzB;AAOA,QAAME,cAAc,GAAG3R,aAAa,CAACC,UAAD,EAAa,MAAb,CAApC;AACA,QAAM2R,eAAe,GAAG5R,aAAa,CAACC,UAAD,EAAa,OAAb,CAArC;;AAEA,WAASyR,OAAT,CAAiB;AACfF,IAAAA,UADe;AAEfC,IAAAA;AAFe,GAAjB,EAGGI,MAHH,EAGW;AACT,WAAO;AACLL,MAAAA,UAAU,EAAEM,iBAAiB,CAACN,UAAD,EAAaK,MAAb,CADxB;AAELJ,MAAAA,gBAAgB,EAAEM,mBAAmB,CAACN,gBAAD,EAAmBI,MAAnB;AAFhC,KAAP;AAID;;AAED,WAASC,iBAAT,CAA2B5S,KAA3B,EAAkC;AAChC4E,IAAAA,IADgC;AAEhCb,IAAAA;AAFgC,GAAlC,EAGG;AACD,YAAQa,IAAR;AACE,WAAK1F,qBAAqB,CAAC4T,KAA3B;AACE,eAAOxU,iBAAP;;AAEF,WAAKY,qBAAqB,CAACiM,GAA3B;AACE,eAAOpH,KAAP;;AAEF,WAAK7E,qBAAqB,CAACkM,KAA3B;AACE,eAAOpL,KAAK,KAAK+D,KAAV,GAAkBzF,iBAAlB,GAAsC0B,KAA7C;;AAEF,WAAKd,qBAAqB,CAAC6T,QAA3B;AACE;AACE,cAAIC,CAAC,GAAGhT,KAAR;AACAgT,UAAAA,CAAC;AACD,cAAIA,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGlB,cAAc,CAAChI,OAAf,GAAyB,CAA7B;AACX,iBAAOkJ,CAAP;AACD;;AAEH,WAAK9T,qBAAqB,CAAC+T,QAA3B;AACE;AACE,cAAID,CAAC,GAAGhT,KAAR;AACAgT,UAAAA,CAAC;AACD,cAAIA,CAAC,IAAIlB,cAAc,CAAChI,OAAxB,EAAiCkJ,CAAC,GAAG,CAAJ;AACjC,iBAAOA,CAAP;AACD;;AAEH,WAAK9T,qBAAqB,CAACgU,KAA3B;AACE,eAAOpB,cAAc,CAAChI,OAAf,GAAyB,CAAzB,GAA6B,CAA7B,GAAiCxL,iBAAxC;;AAEF,WAAKY,qBAAqB,CAACiU,IAA3B;AACE,eAAOrB,cAAc,CAAChI,OAAf,GAAyB,CAAzB,GAA6BgI,cAAc,CAAChI,OAAf,GAAyB,CAAtD,GAA0DxL,iBAAjE;;AAEF;AACE,eAAO0B,KAAP;AAjCJ;AAmCD;;AAED,QAAMoT,SAAS,GAAGrW,OAAO,CAAC,MAAM;AAC9B,UAAM;AACJ2H,MAAAA,KADI;AAEJX,MAAAA,KAFI;AAGJU,MAAAA;AAHI,QAIFJ,aAAa,CAACC,QAAD,CAJjB;AAKAwN,IAAAA,cAAc,CAAChI,OAAf,GAAyB/F,KAAzB;AACAkO,IAAAA,kBAAkB,CAACnI,OAAnB,GAA6BrF,eAA7B;AACA,WAAOC,KAAP;AACD,GATwB,EAStB,CAACJ,QAAD,CATsB,CAAzB;;AAWA,QAAM+O,aAAa,GAAG9Q,CAAC,IAAI;AACzB,QAAI+Q,OAAO,GAAG,KAAd;;AAEA,YAAQ/Q,CAAC,CAAChC,GAAV;AACE,WAAKxB,IAAI,CAACwU,IAAV;AACEvI,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAACgU;AADrB,SAAD,CAAR;AAGAI,QAAAA,OAAO,GAAG,IAAV;AACA;;AAEF,WAAKvU,IAAI,CAACyU,GAAV;AACExI,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAACiU;AADrB,SAAD,CAAR;AAGAG,QAAAA,OAAO,GAAG,IAAV;AACA;;AAEF,WAAKvU,IAAI,CAAC0U,EAAV;AACEzI,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAAC6T;AADrB,SAAD,CAAR;AAGAO,QAAAA,OAAO,GAAG,IAAV;AACA;;AAEF,WAAKvU,IAAI,CAAC2U,IAAV;AACE1I,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAAC+T;AADrB,SAAD,CAAR;AAGAK,QAAAA,OAAO,GAAG,IAAV;AACA;;AAEF,WAAKvU,IAAI,CAAC0J,KAAV;AACE,YAAIlG,CAAC,CAACoR,MAAF,IAAYpR,CAAC,CAACoR,MAAF,CAASnO,SAAT,CAAmBwD,OAAnB,CAA2BnL,SAA3B,MAA0C,CAAC,CAA3D,EAA8D;AAC5D0E,UAAAA,CAAC,CAACqR,cAAF;AACD;;AAED;AAlCJ;;AAqCA,QAAIN,OAAJ,EAAa;AACX/Q,MAAAA,CAAC,CAACqR,cAAF;AACArR,MAAAA,CAAC,CAACsR,eAAF;AACD;AACF,GA5CD;;AA8CA,QAAMC,kBAAkB,GAAG,MAAM;AAC/B,QAAIrH,SAAS,KAAK,SAAlB,EAA6B;AAC3B+E,MAAAA,eAAe;AAChB;;AAEDvQ,IAAAA,QAAQ,CAACgL,aAAD,CAAR;AACD,GAND;;AAQA,QAAM8H,cAAc,GAAG3W,WAAW,CAAC,MAAM;AACvC,QAAI,CAAC+P,YAAY,CAACrD,OAAlB,EAA2B;AACzB,UAAI,CAACnK,MAAL,EAAa,MAAM,IAAIyE,KAAJ,CAAU,+OAAV,CAAN;AACb;AACD;;AAED,QAAI,CAACgJ,YAAY,CAACtD,OAAlB,EAA2B;AACzBsD,MAAAA,YAAY,CAACtD,OAAb,GAAuBnD,cAAc,GAAGA,cAAc,CAACmD,OAAlB,GAA4B3G,iBAAiB,CAACwO,WAAW,CAAC7H,OAAb,CAAlF;AACD;;AAED,UAAM6E,eAAe,GAAG1B,kBAAkB,CAAC;AACzCC,MAAAA,OADyC;AAEzCC,MAAAA,YAFyC;AAGzCC,MAAAA,YAHyC;AAIzCxG,MAAAA;AAJyC,KAAD,CAA1C;AAMA,UAAM;AACJyG,MAAAA;AADI,QAEFsB,eAFJ;AAGA,QAAIqF,OAAO,GAAG;AACZlF,MAAAA,iBAAiB,EAAE;AADP,KAAd;;AAIA,QAAIF,WAAJ,EAAiB;AACfoF,MAAAA,OAAO,GAAGtF,mBAAmB,CAAC;AAC5BC,QAAAA,eAD4B;AAE5BC,QAAAA;AAF4B,OAAD,CAA7B;AAID,KALD,MAKO,IAAI0B,SAAJ,EAAe;AACpB0D,MAAAA,OAAO,GAAG3D,YAAY,CAAC;AACrB5K,QAAAA,KADqB;AAErBK,QAAAA,KAFqB;AAGrBE,QAAAA,SAHqB;AAIrBL,QAAAA,OAJqB;AAKrBE,QAAAA,OALqB;AAMrBI,QAAAA,QANqB;AAOrBqK,QAAAA,SAPqB;AAQrBrB,QAAAA,QARqB;AASrBN,QAAAA;AATqB,OAAD,CAAtB;AAWD;;AAED,QAAI;AACFyB,MAAAA,MADE;AAEFR,MAAAA,MAFE;AAGF/B,MAAAA,CAHE;AAIFI,MAAAA,CAJE;AAKFa,MAAAA;AALE,QAMAkF,OANJ;AAOA,QAAIC,UAAU,GAAG5G,QAAQ,CAACc,MAA1B;;AAEA,QAAI5K,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,YAAM;AACJyK,QAAAA,cADI;AAEJE,QAAAA;AAFI,UAGFS,eAHJ;AAIA,UAAIR,MAAJ,EAAY+F,WAAZ;AACA,YAAMC,UAAU,GAAGpC,cAAc,CAACjI,OAAf,CAAuBqE,MAA1C;AACA,YAAMM,cAAc,GAAGP,iBAAiB,CAACD,CAAD,CAAxC;;AAEA,UAAIQ,cAAc,GAAG,CAAjB,IAAsBjO,UAAU,CAACiO,cAAD,EAAiB,CAAjB,CAAV,IAAiCjO,UAAU,CAACyT,UAAD,EAAaE,UAAb,CAArE,EAA+F;AAC7FhG,QAAAA,MAAM,GAAG8F,UAAU,GAAGxF,cAAtB;AACAyF,QAAAA,WAAW,GAAGzF,cAAd;AACD,OAHD,MAGO;AACL,cAAMD,WAAW,GAAGR,cAAc,CAACC,CAAD,CAAlC;;AAEA,YAAIO,WAAW,GAAG,CAAd,IAAmBhO,UAAU,CAACgO,WAAD,EAAc,CAAd,CAAV,IAA8BhO,UAAU,CAACyT,UAAD,EAAaE,UAAb,CAA/D,EAAyF;AACvFhG,UAAAA,MAAM,GAAG8F,UAAU,GAAGzF,WAAtB;AACA0F,UAAAA,WAAW,GAAG,IAAI1F,WAAlB;AACA,cAAIL,MAAM,IAAI,CAAd,EAAiBF,CAAC,IAAIO,WAAL;AAClB;AACF;;AAED,UAAIL,MAAM,IAAI,CAAd,EAAiB;AACf8F,QAAAA,UAAU,GAAG9F,MAAb;AACAqD,QAAAA,eAAe,CAAC;AACdrD,UAAAA,MADc;AAEd+F,UAAAA;AAFc,SAAD,CAAf;AAID,OAND,MAMO;AACL1C,QAAAA,eAAe;AAChB;AACF;;AAED,QAAI/L,KAAJ,EAAW6L,gBAAgB,CAAC;AAC1BzD,MAAAA,CAAC,EAAEuC,MADuB;AAE1BnC,MAAAA,CAAC,EAAE2B;AAFuB,KAAD,CAAhB;AAIXwB,IAAAA,eAAe,CAAC;AACdvD,MAAAA,CADc;AAEdI,MAAAA;AAFc,KAAD,CAAf;AAIAyD,IAAAA,oBAAoB,CAAC5C,iBAAD,CAApB;AACAiD,IAAAA,cAAc,CAACjI,OAAf,GAAyB;AACvBiE,MAAAA,KAAK,EAAEV,QAAQ,CAACU,KADO;AAEvBI,MAAAA,MAAM,EAAE8F;AAFe,KAAzB;AAID,GAjGiC,EAiG/B,CAACxO,KAAD,EAAQK,KAAR,EAAec,kBAAf,EAAmCZ,SAAnC,EAA8CL,OAA9C,EAAuDE,OAAvD,EAAgEI,QAAhE,EAA0E1C,QAA1E,EAAoFqL,WAApF,EAAiG0B,SAAjG,EAA4GnD,YAA5G,EAA0HxG,cAA1H,EAA0IgL,WAA1I,EAAuJvE,YAAvJ,CAjG+B,CAAlC;AAkGAxC,EAAAA,yBAAyB,CAAC,MAAM;AAC9B,QAAIiB,MAAJ,EAAY;AACVkI,MAAAA,cAAc;AACd,UAAIjI,QAAQ,CAAChC,OAAb,EAAsBsI,iBAAiB;AACxC;;AAEDtG,IAAAA,QAAQ,CAAChC,OAAT,GAAmB+B,MAAnB;AACAmG,IAAAA,oBAAoB,CAAClI,OAArB,GAA+BiK,cAA/B;AACD,GARwB,EAQtB,CAAClI,MAAD,EAASkI,cAAT,EAAyB7B,SAAzB,CARsB,CAAzB;AASAtH,EAAAA,yBAAyB,CAAC,MAAM;AAC9B,QAAI2G,YAAY,IAAI,CAACU,kBAAkB,CAACnI,OAAxC,EAAiDoD,OAAO,CAACpD,OAAR,CAAgBsK,SAAhB,GAA4B,CAA5B;AAClD,GAFwB,EAEtB,CAAC7C,YAAD,CAFsB,CAAzB;AAGAtU,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAAC4O,MAAL,EAAa;;AAEb,QAAI,CAACgG,kBAAkB,CAAC/H,OAApB,IAA+B8H,aAA/B,IAAgDA,aAAa,CAAC9H,OAAd,CAAsBuK,OAA1E,EAAmF;AACjFxC,MAAAA,kBAAkB,CAAC/H,OAAnB,GAA6B3G,iBAAiB,CAACyO,aAAa,CAAC9H,OAAf,CAA9C;AACD;;AAED,UAAMwK,aAAa,GAAGlH,YAAY,CAACtD,OAAnC;AACA,UAAMyK,UAAU,GAAGD,aAAa,IAAIA,aAAa,CAACE,gBAA/B,GAAkDF,aAAlD,GAAkEzQ,MAArF;AACA,UAAM4Q,YAAY,GAAG5C,kBAAkB,CAAC/H,OAAnB,IAA8ByK,UAAnD;AACA,QAAIG,MAAM,GAAG3N,UAAb;AACA,QAAI0N,YAAY,KAAKF,UAAjB,IAA+BG,MAAM,KAAK,SAA9C,EAAyDA,MAAM,GAAG,MAAT;AACzD,QAAIA,MAAM,KAAK,SAAf,EAA0B;AAC1B,QAAIA,MAAM,KAAK,MAAX,IAAqBnR,QAAQ,KAAK,SAAtC,EAAiDmR,MAAM,GAAG,OAAT;;AAEjD,UAAMC,YAAY,GAAG,MAAM;AACzB,UAAID,MAAM,KAAK,MAAf,EAAuB;AACrBzU,QAAAA,cAAc,CAAC8T,cAAD,CAAd;AACD,OAFD,MAEO;AACL9S,QAAAA,QAAQ,CAACiQ,OAAD,EAAU;AAChB0D,UAAAA,MAAM,EAAExV,WAAW,CAACyV;AADJ,SAAV,CAAR;AAGD;AACF,KARD;;AAUA,UAAMC,eAAe,GAAGL,YAAY,KAAKF,UAAjB,IAA+BxN,UAAU,KAAK,SAA9C,GAA0D,CAAC0N,YAAD,EAAeF,UAAf,CAA1D,GAAuF,CAACE,YAAD,CAA/G;AACAK,IAAAA,eAAe,CAACC,OAAhB,CAAwBC,CAAC,IAAIA,CAAC,CAACR,gBAAF,CAAmB,QAAnB,EAA6BG,YAA7B,CAA7B;AACA,WAAO,MAAMG,eAAe,CAACC,OAAhB,CAAwBC,CAAC,IAAIA,CAAC,CAACC,mBAAF,CAAsB,QAAtB,EAAgCN,YAAhC,CAA7B,CAAb;AACD,GA5BQ,EA4BN,CAAC/C,aAAD,EAAgBC,kBAAhB,EAAoCzE,YAApC,EAAkDvB,MAAlD,EAA0DtI,QAA1D,EAAoE2N,OAApE,EAA6EnK,UAA7E,EAAyFgN,cAAzF,CA5BM,CAAT;AA6BA,QAAMmB,WAAW,GAAG,CAAC,CAAC3D,YAAF,IAAkBA,YAAY,CAAC2C,WAAb,GAA2B,CAAjE;AACAjX,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIiY,WAAW,IAAI,CAACrJ,MAAhB,IAA0B,CAACkF,kBAA/B,EAAmD;;AAEnD,UAAM4D,YAAY,GAAG,MAAM1U,cAAc,CAAC8T,cAAD,CAAzC;;AAEA,UAAMoB,YAAY,GAAGpE,kBAAkB,CAACjH,OAAxC;AACAqL,IAAAA,YAAY,CAACX,gBAAb,CAA8B,QAA9B,EAAwCG,YAAxC;AACA,WAAO,MAAMQ,YAAY,CAACF,mBAAb,CAAiC,QAAjC,EAA2CN,YAA3C,CAAb;AACD,GARQ,EAQN,CAAC9I,MAAD,EAASqJ,WAAT,EAAsBnE,kBAAtB,EAA0CgD,cAA1C,CARM,CAAT;AASA9W,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,OAAOmY,cAAP,KAA0B,UAA1B,IAAwCvO,UAAU,KAAK,SAA3D,EAAsE;AACtE,UAAMwO,cAAc,GAAG,IAAID,cAAJ,CAAmB,CAAC,CAACE,KAAD,CAAD,KAAa;AACrD,YAAM;AACJC,QAAAA,aADI;AAEJ5B,QAAAA;AAFI,UAGF2B,KAHJ;AAIA,UAAIvH,KAAJ,EAAWI,MAAX;;AAEA,UAAIoH,aAAJ,EAAmB;AACjB,cAAM;AACJC,UAAAA,UADI;AAEJC,UAAAA;AAFI,YAGFF,aAAa,CAAC,CAAD,CAAb,IAAoBA,aAHxB;AAIAxH,QAAAA,KAAK,GAAGyH,UAAR;AACArH,QAAAA,MAAM,GAAGsH,SAAT;AACD,OAPD,MAOO;AACL,cAAMC,UAAU,GAAG/B,MAAM,CAACrG,qBAAP,EAAnB;AACAS,QAAAA,KAAK,GAAG2H,UAAU,CAAC3H,KAAnB;AACAI,QAAAA,MAAM,GAAGuH,UAAU,CAACvH,MAApB;AACD;;AAED,UAAIJ,KAAK,KAAK,CAAV,IAAeI,MAAM,KAAK,CAA9B,EAAiC;AACjC,UAAI3N,UAAU,CAACuN,KAAD,EAAQgE,cAAc,CAACjI,OAAf,CAAuBiE,KAA/B,EAAsC,CAAtC,CAAV,IAAsDvN,UAAU,CAAC2N,MAAD,EAAS4D,cAAc,CAACjI,OAAf,CAAuBqE,MAAhC,EAAwC,CAAxC,CAApE,EAAgH;AAChHlO,MAAAA,cAAc,CAAC,MAAM;AACnB+R,QAAAA,oBAAoB,CAAClI,OAArB;AACAsI,QAAAA,iBAAiB;AAClB,OAHa,CAAd;AAID,KA1BsB,CAAvB;AA2BA,UAAMuD,aAAa,GAAGzI,OAAO,CAACpD,OAA9B;AACAuL,IAAAA,cAAc,CAACO,OAAf,CAAuBD,aAAvB,EAAsC;AACpCE,MAAAA,GAAG,EAAE;AAD+B,KAAtC;AAGA,WAAO,MAAMR,cAAc,CAACS,SAAf,CAAyBH,aAAzB,CAAb;AACD,GAlCQ,EAkCN,CAAC9O,UAAD,CAlCM,CAAT;AAmCA5J,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAAC4O,MAAL,EAAa;AACXb,MAAAA,QAAQ,CAAC;AACPpG,QAAAA,IAAI,EAAE1F,qBAAqB,CAAC4T;AADrB,OAAD,CAAR;AAGA,UAAI,CAACJ,eAAL,EAAsBlB,eAAe;AACrC;AACD;;AAED,UAAMuE,EAAE,GAAGzK,UAAU,CAAC,MAAM;AAC1B,UAAI,CAAC4B,OAAO,CAACpD,OAAb,EAAsB;AACtB,YAAM;AACJ7D,QAAAA,QADI;AAEJ4G,QAAAA;AAFI,UAGFH,aAAa,IAAI,EAHrB;AAIA,UAAI,CAACG,YAAD,IAAiBK,OAAO,CAACpD,OAAR,CAAgBV,QAAhB,CAAyB/F,QAAQ,CAAC2S,aAAlC,CAArB,EAAuE;AACvE,UAAI/E,aAAJ,EAAmB/D,OAAO,CAACpD,OAAR,CAAgB6B,KAAhB;;AAEnB,UAAI1F,QAAQ,KAAK5G,cAAc,CAAC6T,KAAhC,EAAuC;AACrClI,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAACgU;AADrB,SAAD,CAAR;AAGD,OAJD,MAIO,IAAIjN,QAAQ,KAAK5G,cAAc,CAAC8T,IAAhC,EAAsC;AAC3CnI,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAACiU;AADrB,SAAD,CAAR;AAGD,OAJM,MAIA,IAAIlN,QAAQ,IAAI,CAAZ,IAAiBA,QAAQ,GAAG6L,cAAc,CAAChI,OAA/C,EAAwD;AAC7DkB,QAAAA,QAAQ,CAAC;AACPpG,UAAAA,IAAI,EAAE1F,qBAAqB,CAACiM,GADrB;AAEPpH,UAAAA,KAAK,EAAEkC;AAFA,SAAD,CAAR;AAID;AACF,KAvBoB,EAuBlBwM,cAAc,GAAG,GAAH,GAAS,GAvBL,CAArB;AAwBA,WAAO,MAAM/G,YAAY,CAACqK,EAAD,CAAzB;AACD,GAlCQ,EAkCN,CAACtD,cAAD,EAAiBC,eAAjB,EAAkCzB,aAAlC,EAAiDpF,MAAjD,EAAyDa,aAAzD,CAlCM,CAAT;AAmCA,QAAM3B,aAAa,GAAGwH,gBAAgB,GAAG,CAAzC;AACA,QAAM0D,WAAW,GAAGlZ,OAAO,CAAC,OAAO;AACjCmZ,IAAAA,aAAa,EAAEhJ,OADkB;AAEjCiJ,IAAAA,cAAc,EAAE5S,QAFiB;AAGjCuH,IAAAA,YAAY,EAAEe,MAHmB;AAIjCd,IAAAA,aAJiC;AAKjCC,IAAAA;AALiC,GAAP,CAAD,EAMvB,CAACa,MAAD,EAASd,aAAT,EAAwBxH,QAAxB,CANuB,CAA3B;AAOA,MAAI6S,SAAJ,EAAelC,WAAf;;AAEA,MAAI3C,YAAJ,EAAkB;AAChBU,IAAAA,kBAAkB,CAACnI,OAAnB,GAA6BoK,WAAW,GAAG3C,YAAY,CAAC2C,WAAxD,GAAsEkC,SAAS,GAAG7E,YAAY,CAACpD,MAA/F;AACD;;AAED,QAAMkI,WAAW,GAAGtZ,OAAO,CAAC,OAAO;AACjCoV,IAAAA,YADiC;AAEjC5O,IAAAA,QAFiC;AAGjC2Q,IAAAA;AAHiC,GAAP,CAAD,EAIvB,CAAC/B,YAAD,EAAe5O,QAAf,EAAyB2Q,WAAzB,CAJuB,CAA3B;AAKA,QAAMoC,cAAc,GAAGF,SAAS,IAAI,CAAb,GAAiB;AACtCA,IAAAA,SADsC;AAEtC7S,IAAAA;AAFsC,GAAjB,GAGnBU,SAHJ;AAIA,QAAMwF,SAAS,GAAG1M,OAAO,CAAC,OAAO;AAC/BiD,IAAAA,KAAK,EAAEyM,SADwB;AAE/B8J,IAAAA,GAAG,EAAE9E;AAF0B,GAAP,CAAD,EAGrB,CAAChF,SAAD,EAAYgF,iBAAZ,CAHqB,CAAzB;AAIA,QAAM+E,cAAc,GAAGzZ,OAAO,CAAC,MAAMiC,MAAM,CAACC,MAAP,CAAc;AACjDsX,IAAAA,GAAG,EAAE9E;AAD4C,GAAd,CAAP,EAE1B,CAACA,iBAAD,CAF0B,CAA9B;;AAIA,QAAMgF,WAAW,GAAGnN,MAAM,CAAC;AACzBC,IAAAA,KAAK,EAAE1L,SADkB;AAEzB2L,IAAAA,OAAO,EAAEzL,cAFgB;AAGzB0L,IAAAA,SAAS,EAAE+M,cAHc;AAIzBhR,IAAAA,SAAS,EAAEqL;AAJc,GAAD,CAA1B;;AAOA,QAAM6F,YAAY,GAAGrM,aAAa,CAACyG,WAAD,EAAc0F,cAAd,CAAlC;;AAEA,QAAMxU,QAAQ,GAAGD,kBAAkB,CAAC;AAClCgH,IAAAA,SAAS,EAAEsK,aADuB;AAElCsD,IAAAA,cAAc,EAAE7C;AAFkB,GAAD,EAGhC/G,SAHgC,CAAnC;AAIA,SAAO,aAAatQ,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B9I,MAAM,CAAC+I,MAAP,CAAc;AAC1D6O,IAAAA,IAAI,EAAE,MADoD;AAE1DC,IAAAA,QAAQ,EAAE,IAFgD;AAG1D,qBAAiB7S,UAAU,IAAIC,SAH2B;AAI1D,kBAAcyM;AAJ4C,GAAd,EAK3C3D,SAL2C,EAKhC/K,QALgC,EAKtB;AACtB6F,IAAAA,GAAG,EAAEkC,cAAc,CAAC/B,WAAD,EAAckF,OAAd,CADG;AAEtB1H,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB4L,MAAAA,SAFgB;AAGhBjE,MAAAA,SAAS,EAAEmL;AAHK,KAAD,CAFK;AAOtBpG,IAAAA,KAAK,EAAE,EAAE,GAAGF,aAAa,CAACuG,UAAD,EAAanH,SAAb,CAAlB;AACL,SAAG6M,cADE;AAELzT,MAAAA,IAAI,EAAG,GAAEsO,YAAY,CAACtD,CAAE,IAFnB;AAGLnL,MAAAA,GAAG,EAAG,GAAEyO,YAAY,CAAClD,CAAE;AAHlB;AAPe,GALsB,CAA1B,EAiBhBxI,KAAK,IAAI,aAAahJ,KAAK,CAACqL,aAAN,CAAoB,KAApB,EAA2B;AACnDtC,IAAAA,SAAS,EAAEiR,WADwC;AAEnDlM,IAAAA,KAAK,EAAE,EAAE,GAAGmM,YAAL;AACL7T,MAAAA,IAAI,EAAEwO,aAAa,CAACxD,CAAd,IAAoB,GAAEwD,aAAa,CAACxD,CAAE,IADvC;AAELnL,MAAAA,GAAG,EAAE2O,aAAa,CAACpD,CAAd,IAAoB,GAAEoD,aAAa,CAACpD,CAAE;AAFtC,KAF4C;AAMnDpG,IAAAA,GAAG,EAAEoH;AAN8C,GAA3B,CAjBN,EAwBhB,aAAaxS,KAAK,CAACqL,aAAN,CAAoBpJ,eAAe,CAACoY,QAApC,EAA8C;AAC7DtV,IAAAA,KAAK,EAAE6U;AADsD,GAA9C,EAEd,aAAa5Z,KAAK,CAACqL,aAAN,CAAoBrJ,mBAAmB,CAACqY,QAAxC,EAAkD;AAChEtV,IAAAA,KAAK,EAAEyU;AADyD,GAAlD,EAEb,aAAaxZ,KAAK,CAACqL,aAAN,CAAoBvJ,iBAAiB,CAACuY,QAAtC,EAAgD;AAC9DtV,IAAAA,KAAK,EAAE8Q;AADuD,GAAhD,EAEbc,SAFa,CAFA,CAFC,CAxBG,CAApB;AA+BD,CA/dD;;AAieA,SAASP,mBAAT,CAA6B7S,KAA7B,EAAoC;AAClC4E,EAAAA;AADkC,CAApC,EAEG;AACD,UAAQA,IAAR;AACE,SAAKzF,kBAAkB,CAAC4X,IAAxB;AACE,aAAO/W,KAAK,GAAG,CAAf;;AAEF,SAAKb,kBAAkB,CAAC6X,KAAxB;AACE,aAAOpW,IAAI,CAAC0O,GAAL,CAAStP,KAAK,GAAG,CAAjB,EAAoB,CAApB,CAAP;;AAEF;AACE,aAAOA,KAAP;AARJ;AAUD;;AAED,MAAMiX,cAAc,GAAG,aAAara,UAAU,CAAC,SAASqa,cAAT,CAAwB;AACrE,gBAAcvG,SADuD;AAErElL,EAAAA,SAFqE;AAGrEW,EAAAA,cAHqE;AAIrEC,EAAAA,cAJqE;AAKrEC,EAAAA,cALqE;AAMrEtF,EAAAA,UANqE;AAOrE2F,EAAAA,iBAPqE;AAQrEC,EAAAA,cARqE;AASrEC,EAAAA,kBATqE;AAUrEC,EAAAA,UAVqE;AAWrEG,EAAAA,gBAXqE;AAYrEC,EAAAA,iBAZqE;AAarEiQ,EAAAA,QAbqE;AAcrEnQ,EAAAA,UAdqE;AAerEG,EAAAA,MAfqE;AAgBrEC,EAAAA,OAhBqE;AAiBrEC,EAAAA,WAjBqE;AAkBrE8J,EAAAA,OAlBqE;AAmBrE,KAAGnE;AAnBkE,CAAxB,EAoB5C/E,WApB4C,EAoB/B;AACd,QAAMmF,YAAY,GAAGjQ,MAAM,CAAC,IAAD,CAA3B;AACA,QAAMkQ,YAAY,GAAGlQ,MAAM,CAAC,IAAD,CAA3B;AACA,QAAM2U,kBAAkB,GAAG3U,MAAM,CAAC,IAAD,CAAjC;AACA,QAAM;AACJoT,IAAAA,SADI;AAEJtQ,IAAAA;AAFI,MAGF+M,SAHJ;AAIA,QAAMoK,QAAQ,GAAGpa,OAAO,CAAC,OAAO;AAC9BqJ,IAAAA,cAD8B;AAE9BC,IAAAA,cAF8B;AAG9BtF,IAAAA,UAH8B;AAI9B2F,IAAAA,iBAJ8B;AAK9BC,IAAAA,cAL8B;AAM9BC,IAAAA,kBAN8B;AAO9B+K,IAAAA,WAAW,EAAExE,YAPiB;AAQ9ByE,IAAAA,aAAa,EAAEtB,SARe;AAS9BlD,IAAAA,YAT8B;AAU9ByE,IAAAA,kBAV8B;AAW9BhL,IAAAA,UAX8B;AAY9BE,IAAAA;AAZ8B,GAAP,CAAD,EAapB,CAACX,cAAD,EAAiBC,cAAjB,EAAiCtF,UAAjC,EAA6C2F,iBAA7C,EAAgE4J,SAAhE,EAA2E3J,cAA3E,EAA2FC,kBAA3F,EAA+GC,UAA/G,EAA2HE,UAA3H,CAboB,CAAxB;AAcA,QAAMqQ,YAAY,GAAGra,OAAO,CAAC,OAAO;AAClCiK,IAAAA,gBADkC;AAElCC,IAAAA;AAFkC,GAAP,CAAD,EAGxB,CAACD,gBAAD,EAAmBC,iBAAnB,CAHwB,CAA5B;AAIA,QAAMoQ,aAAa,GAAGta,OAAO,CAAC,OAAO;AACnCua,IAAAA,WAAW,CAACC,KAAD,EAAQC,cAAR,EAAwB;AACjC,UAAI,CAACD,KAAK,CAAC1D,eAAX,EAA4B5S,QAAQ,CAACmG,WAAD,EAAcmQ,KAAd,CAAR;AAC5B,UAAIE,QAAQ,GAAGF,KAAK,CAACE,QAArB;;AAEA,UAAIA,QAAQ,KAAKxT,SAAjB,EAA4B;AAC1BwT,QAAAA,QAAQ,GAAGD,cAAc,IAAID,KAAK,CAAChX,GAAN,KAAcxB,IAAI,CAAC0J,KAAhD;AACD;;AAED,UAAI,CAACgP,QAAL,EAAe;AACbxW,QAAAA,QAAQ,CAACiQ,OAAD,EAAU;AAChB1P,UAAAA,KAAK,EAAE+V,KAAK,CAAC/V,KADG;AAEhBjB,UAAAA,GAAG,EAAEgX,KAAK,CAAChX,GAFK;AAGhBqU,UAAAA,MAAM,EAAExV,WAAW,CAACsY;AAHJ,SAAV,CAAR;AAKD;AACF,KAhBkC;;AAkBnCC,IAAAA,WAAW,CAACpX,GAAD,EAAM;AACfU,MAAAA,QAAQ,CAACiQ,OAAD,EAAU;AAChB3Q,QAAAA,GADgB;AAEhBqU,QAAAA,MAAM,EAAExV,WAAW,CAACsY;AAFJ,OAAV,CAAR;AAID;;AAvBkC,GAAP,CAAD,EAyBzB,CAACtQ,WAAD,EAAc8J,OAAd,CAzByB,CAA7B;;AA2BA,QAAMmC,aAAa,GAAG,CAAC;AACrB9S,IAAAA;AADqB,GAAD,KAEhB;AACJ,YAAQA,GAAR;AACE,WAAKxB,IAAI,CAAC6Y,GAAV;AACE3W,QAAAA,QAAQ,CAACiQ,OAAD,EAAU;AAChB3Q,UAAAA,GADgB;AAEhBqU,UAAAA,MAAM,EAAExV,WAAW,CAACyY;AAFJ,SAAV,CAAR;AAIA;AANJ;AAQD,GAXD;;AAaA,QAAMC,UAAU,GAAGvV,CAAC,IAAI;AACtB,QAAIxC,UAAU,CAACC,KAAD,CAAV,IAAqB,CAACuC,CAAC,CAAC4G,aAAF,CAAgBC,QAAhB,CAAyB7G,CAAC,CAAC8G,aAAF,IAAmBhG,QAAQ,CAAC2S,aAArD,CAA1B,EAA+F;AAC7F/U,MAAAA,QAAQ,CAACiQ,OAAD,EAAU;AAChB0D,QAAAA,MAAM,EAAExV,WAAW,CAAC2Y;AADJ,OAAV,CAAR;;AAIA,UAAIb,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACpN,OAAT,GAAmB,IAAnB;AACAwB,QAAAA,UAAU,CAAC,MAAM4L,QAAQ,CAACpN,OAAT,GAAmB,KAA1B,EAAiC,GAAjC,CAAV;AACD;AACF;AACF,GAXD;;AAaA,QAAMkO,cAAc,GAAGlX,aAAa,CAACC,UAAD,EAAa,MAAb,CAApC;AACA,QAAM0I,SAAS,GAAG1M,OAAO,CAAC,OAAO;AAC/Bkb,IAAAA,KAAK,EAAE9Q,OADwB;AAE/B6Q,IAAAA;AAF+B,GAAP,CAAD,EAGrB,CAAC7Q,OAAD,EAAU6Q,cAAV,CAHqB,CAAzB;AAIA,QAAMhW,QAAQ,GAAGD,kBAAkB,CAAC;AAClCgH,IAAAA,SAAS,EAAEsK,aADuB;AAElCnK,IAAAA,MAAM,EAAE4O;AAF0B,GAAD,EAGhC3R,cAHgC,CAAnC;AAIA,QAAM+R,QAAQ,GAAG,aAAazb,KAAK,CAACqL,aAAN,CAAoB,KAApB,EAA2B9I,MAAM,CAAC+I,MAAP,CAAc,EAAd,EAAkB5B,cAAlB,EAAkCnE,QAAlC,EAA4C;AACnGwD,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE3L,kBADS;AAEhB6L,MAAAA,SAFgB;AAGhBjE,MAAAA;AAHgB,KAAD,CADkF;AAMnGqC,IAAAA,GAAG,EAAEsF;AAN8F,GAA5C,CAA3B,EAO1BnN,KAAK,IAAI,aAAavD,KAAK,CAACqL,aAAN,CAAoBjJ,eAAe,CAACiY,QAApC,EAA8C;AACtEtV,IAAAA,KAAK,EAAE2V;AAD+D,GAA9C,EAEvB,aAAa1a,KAAK,CAACqL,aAAN,CAAoBhJ,mBAAmB,CAACgY,QAAxC,EAAkD;AAChEtV,IAAAA,KAAK,EAAE4V;AADyD,GAAlD,EAEb,aAAa3a,KAAK,CAACqL,aAAN,CAAoBnJ,oBAAoB,CAACmY,QAAzC,EAAmD;AACjEtV,IAAAA,KAAK,EAAE6V;AAD0D,GAAnD,EAEb,aAAa5a,KAAK,CAACqL,aAAN,CAAoB2I,QAApB,EAA8BzR,MAAM,CAAC+I,MAAP,CAAc,EAAd,EAAkBgF,SAAlB,EAA6B;AACzE2D,IAAAA,SAAS,EAAEA,SAAS,IAAI,MADiD;AAEzE1I,IAAAA,WAAW,EAAEA,WAF4D;AAGzEmF,IAAAA,YAAY,EAAEA,YAH2D;AAIzE+D,IAAAA,OAAO,EAAEA;AAJgE,GAA7B,CAA9B,CAFA,CAFA,CAFU,CAPI,CAA9B;;AAoBA,MAAIhK,MAAJ,EAAY;AACV,WAAO,aAAa3J,QAAQ,CAACE,YAAT,CAAsBya,QAAtB,EAAgC7U,QAAQ,CAACC,IAAzC,CAApB;AACD,GAFD,MAEO;AACL,WAAO4U,QAAP;AACD;AACF,CArI6C,CAA9C;AAsIAjB,cAAc,CAACjK,SAAf,GAA2B,EAAE,GAAG9G,iBAAL;AACzBlG,EAAAA,KAAK,EAAEtC,SAAS,CAACqI,KAAV,CAAgB5F,MAAM,CAACb,YAAD,CAAtB,CADkB;AAEzBsP,EAAAA,WAAW,EAAElR,SAAS,CAAC4I,KAAV,CAAgB;AAC3BuH,IAAAA,CAAC,EAAEnQ,SAAS,CAACkI,MADc;AAE3BqI,IAAAA,CAAC,EAAEvQ,SAAS,CAACkI;AAFc,GAAhB,CAFY;AAMzB0K,EAAAA,SAAS,EAAE5S,SAAS,CAAC4H,MANI;AAOzB4R,EAAAA,QAAQ,EAAExZ,SAAS,CAAC4H,MAPK;AAQzB0L,EAAAA,YAAY,EAAEtT,SAAS,CAACgI,IARC;AASzBgH,EAAAA,aAAa,EAAEhP,SAAS,CAAC4I,KAAV,CAAgB;AAC7BL,IAAAA,QAAQ,EAAEvI,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC0H,MAAX,EAAmB1H,SAAS,CAACkI,MAA7B,CAApB,CADmB;AAE7BiH,IAAAA,YAAY,EAAEnP,SAAS,CAACgI;AAFK,GAAhB,CATU;AAazBwL,EAAAA,OAAO,EAAExT,SAAS,CAAC2H;AAbM,CAA3B;AAeA4R,cAAc,CAACkB,YAAf,GAA8B,EAAE,GAAG1Q,oBAAL;AAC5BiF,EAAAA,aAAa,EAAE;AADa,CAA9B;AAIA,MAAM0L,IAAI,GAAG,aAAaxb,UAAU,CAAC,SAASwb,IAAT,CAAc;AACjD,gBAAc1H,SADmC;AAEjDM,EAAAA,YAAY,EAAExF,CAFmC;AAGjD6M,EAAAA,UAHiD;AAIjD/Q,EAAAA,WAJiD;AAKjDC,EAAAA,YALiD;AAMjD,KAAGwF;AAN8C,CAAd,EAOlC/E,WAPkC,EAOrB;AACd,QAAM;AACJ4E,IAAAA,QADI;AAEJZ,IAAAA,UAFI;AAGJ,OAAGsM;AAHC,MAIF/L,oBAAoB,CAACQ,SAAD,CAJxB;AAKA,QAAMlB,MAAM,GAAG9L,UAAU,CAACuY,UAAU,CAACtY,KAAZ,CAAzB;AACA,QAAMkX,QAAQ,GAAGha,MAAM,CAAC,KAAD,CAAvB;AACA,QAAMqb,SAAS,GAAGrb,MAAM,CAAC,IAAD,CAAxB;AACA,QAAMya,WAAW,GAAGva,WAAW,CAACmF,CAAC,IAAI;AACnCyJ,IAAAA,UAAU,CAAC,KAAD,CAAV;AACA,QAAIzJ,CAAC,CAAChC,GAAN,EAAWgY,SAAS,CAACzO,OAAV,CAAkB6B,KAAlB;AACZ,GAH8B,EAG5B,CAACK,UAAD,CAH4B,CAA/B;;AAKA,QAAMsL,WAAW,GAAG/U,CAAC,IAAI;AACvB,QAAI2U,QAAQ,CAACpN,OAAb,EAAsB;AACtB8C,IAAAA,QAAQ,CAACrK,CAAC,CAACiW,MAAF,KAAa,CAAb,GAAiBnZ,cAAc,CAAC6T,KAAhC,GAAwCjP,SAAzC,CAAR;AACD,GAHD;;AAKA,QAAMoP,aAAa,GAAG9Q,CAAC,IAAI;AACzB,QAAI+Q,OAAO,GAAG,KAAd;;AAEA,YAAQ/Q,CAAC,CAAChC,GAAV;AACE,WAAKxB,IAAI,CAAC0U,EAAV;AACE7G,QAAAA,QAAQ,CAACvN,cAAc,CAAC8T,IAAhB,CAAR;AACAG,QAAAA,OAAO,GAAG,IAAV;AACA;;AAEF,WAAKvU,IAAI,CAAC2U,IAAV;AACE9G,QAAAA,QAAQ,CAACvN,cAAc,CAAC6T,KAAhB,CAAR;AACAI,QAAAA,OAAO,GAAG,IAAV;AACA;AATJ;;AAYA,QAAIA,OAAJ,EAAa/Q,CAAC,CAACqR,cAAF;AACd,GAhBD;;AAkBA,QAAM6E,MAAM,GAAGxX,QAAQ,CAACoX,UAAD,EAAa;AAClC9R,IAAAA,IAAI,EAAEsF;AAD4B,GAAb,CAAvB;AAGA,MAAI,CAAC4M,MAAL,EAAa,MAAM,IAAIrU,KAAJ,CAAU,kCAAV,CAAN;AACb,QAAMsU,WAAW,GAAG;AAClB7Q,IAAAA,GAAG,EAAEkC,cAAc,CAAC0O,MAAM,CAAC5Q,GAAR,EAAa0Q,SAAb,CADD;AAElB,OAAGxW,kBAAkB,CAAC;AACpB4W,MAAAA,OAAO,EAAErB,WADW;AAEpBvO,MAAAA,SAAS,EAAEsK;AAFS,KAAD,EAGlBoF,MAAM,CAACxW,KAHW;AAFH,GAApB;;AAQA,MAAIb,OAAO,CAACqX,MAAM,CAAC7T,IAAR,CAAP,KAAyB,YAA7B,EAA2C;AACzC8T,IAAAA,WAAW,CAAC7M,MAAZ,GAAqBA,MAArB;AACD;;AAED,QAAM+M,YAAY,GAAG,aAAanc,KAAK,CAACE,YAAN,CAAmB8b,MAAnB,EAA2BC,WAA3B,CAAlC;AACA9M,EAAAA,aAAa,CAACrE,YAAD,EAAesE,MAAf,CAAb;AACAxO,EAAAA,mBAAmB,CAACiK,WAAD,EAAc,OAAO;AACtCsF,IAAAA,QADsC;AAEtCiM,IAAAA,SAAS,EAAE,MAAM7M,UAAU,CAAC,KAAD;AAFW,GAAP,CAAd,CAAnB;AAIA,QAAM8M,SAAS,GAAG,EAAE,GAAG/L,SAAL;AAChB,OAAGuL,UADa;AAEhB,kBAAc5H,SAAS,KAAK,OAAO+H,MAAM,CAACxW,KAAP,CAAaqC,QAApB,KAAiC,QAAjC,GAA4CmU,MAAM,CAACxW,KAAP,CAAaqC,QAAzD,GAAoE,MAAzE,CAFP;AAGhBgM,IAAAA,SAAS,EAAEiI,SAHK;AAIhB1Q,IAAAA,GAAG,EAAEG,WAJW;AAKhBkJ,IAAAA,OAAO,EAAEyG,WALO;AAMhBT,IAAAA;AANgB,GAAlB;AAQA,SAAO,aAAaza,KAAK,CAACqL,aAAN,CAAoBrL,KAAK,CAACsc,QAA1B,EAAoC,IAApC,EAA0CH,YAA1C,EAAwD,aAAanc,KAAK,CAACqL,aAAN,CAAoBmP,cAApB,EAAoC6B,SAApC,CAArE,CAApB;AACD,CA3EmC,CAApC;AA4EAV,IAAI,CAACpL,SAAL,GAAiB,EAAE,GAAG9G,iBAAL;AACf,KAAGmB,yBADY;AAEfgR,EAAAA,UAAU,EAAE3a,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC8L,OAAX,EAAoB9L,SAAS,CAAC2H,IAA9B,CAApB,EAAyD2T;AAFtD,CAAjB;AAIAZ,IAAI,CAACD,YAAL,GAAoB1Q,oBAApB;AAEA,MAAMwR,OAAO,GAAGvR,YAAY,EAAE,aAAapK,IAAI,CAAC,SAAS2b,OAAT,CAAiB;AAC/D,gBAAcvI,SADiD;AAE/DlL,EAAAA,SAF+D;AAG/DX,EAAAA,QAH+D;AAI/DqU,EAAAA,KAJ+D;AAK/DnV,EAAAA,KAL+D;AAM/DwD,EAAAA,YAN+D;AAO/DU,EAAAA,UAP+D;AAQ/DX,EAAAA,WAR+D;AAS/D0J,EAAAA,YAAY,EAAEmI,EATiD;AAU/DrS,EAAAA,cAAc,EAAEsS,EAV+C;AAW/DC,EAAAA,SAAS,GAAG,EAXmD;AAY/D,KAAGtM;AAZ4D,CAAjB,EAa7C;AACD,QAAM/I,UAAU,GAAG,CAAC,CAACa,QAArB;AACAf,EAAAA,aAAa,CAACC,KAAD,EAAQC,UAAR,EAAoBkV,KAApB,CAAb;AACA,QAAM;AACJ9S,IAAAA,cADI;AAEJC,IAAAA,cAFI;AAGJtF,IAAAA,UAHI;AAIJ2F,IAAAA,iBAJI;AAKJiL,IAAAA;AALI,MAMF9U,UAAU,CAACgC,eAAD,CANd;AAOA,QAAM;AACJmI,IAAAA,gBADI;AAEJC,IAAAA;AAFI,MAGFpK,UAAU,CAACiC,mBAAD,CAHd;AAIA,QAAM;AACJoX,IAAAA,aADI;AAEJC,IAAAA,cAFI;AAGJrL,IAAAA,YAHI;AAIJC,IAAAA,aAJI;AAKJC,IAAAA;AALI,MAMFnO,UAAU,CAAC4B,mBAAD,CANd;AAOA,QAAM6a,QAAQ,GAAGnD,cAAc,KAAK,SAApC;AACA,QAAM;AACJvJ,IAAAA,QADI;AAEJZ,IAAAA,UAFI;AAGJhM,IAAAA,KAHI;AAIJ,OAAGuZ;AAJC,MAKFhN,oBAAoB,CAAC;AACvBnG,IAAAA,cADuB;AAEvBC,IAAAA,cAFuB;AAGvBtF,IAAAA,UAHuB;AAIvB2F,IAAAA;AAJuB,GAAD,CALxB;AAWA,QAAMmF,MAAM,GAAG9L,UAAU,CAACC,KAAD,CAAzB;AACA,QAAM;AACJ2I,IAAAA,QADI;AAEJM,IAAAA,OAFI;AAGJ,OAAGuQ;AAHC,MAIFrR,cAAc,CAACF,UAAD,EAAajE,UAAb,EAAyBjF,IAAI,CAAC0a,KAA9B,CAJlB;AAKA,QAAMtM,YAAY,GAAGjQ,MAAM,CAAC,IAAD,CAA3B;AACA,QAAMwc,OAAO,GAAGxc,MAAM,CAAC,IAAD,CAAtB;AACA,QAAM+N,SAAS,GAAG/N,MAAM,EAAxB;;AAEA,QAAMgO,QAAQ,GAAG,MAAM,CAACjD,UAAD,IAAe+C,QAAQ,CAAC;AAC7CpG,IAAAA,IAAI,EAAE1F,qBAAqB,CAACiM,GADiB;AAE7CpH,IAAAA;AAF6C,GAAD,CAA9C;;AAKA,QAAM4V,SAAS,GAAGC,KAAK,IAAI;AACzB5O,IAAAA,QAAQ,CAAC;AACPpG,MAAAA,IAAI,EAAE1F,qBAAqB,CAACiM,GADrB;AAEPpH,MAAAA;AAFO,KAAD,CAAR;AAIAkH,IAAAA,SAAS,CAACnB,OAAV,GAAoBwB,UAAU,CAACsB,QAAD,EAAWhM,IAAI,CAAC0O,GAAL,CAASsK,KAAT,EAAgB,CAAhB,CAAX,CAA9B;AACD,GAND;;AAQA,QAAMC,gBAAgB,GAAG,MAAM;AAC7B,QAAI7V,UAAU,IAAI6H,MAAlB,EAA0B;;AAE1B,QAAId,aAAJ,EAAmB;AACjBE,MAAAA,SAAS,CAACnB,OAAV,GAAoBwB,UAAU,CAAC,MAAMqO,SAAS,CAAC3S,gBAAgB,GAAGC,iBAApB,CAAhB,EAAwDA,iBAAxD,CAA9B;AACD,KAFD,MAEO;AACL0S,MAAAA,SAAS,CAAC3S,gBAAD,CAAT;AACD;AACF,GARD;;AAUA,QAAM8S,gBAAgB,GAAG,MAAM;AAC7BpO,IAAAA,YAAY,CAACT,SAAS,CAACnB,OAAX,CAAZ;;AAEA,QAAI,CAAC+B,MAAL,EAAa;AACXb,MAAAA,QAAQ,CAAC;AACPpG,QAAAA,IAAI,EAAE1F,qBAAqB,CAACkM,KADrB;AAEPrH,QAAAA;AAFO,OAAD,CAAR;AAID;AACF,GATD;;AAWA,QAAMuT,WAAW,GAAG,MAAM;AACxB,QAAItT,UAAJ,EAAgB;AAChB0H,IAAAA,YAAY,CAACT,SAAS,CAACnB,OAAX,CAAZ;AACA8C,IAAAA,QAAQ;AACT,GAJD;;AAMA,QAAMyG,aAAa,GAAG9Q,CAAC,IAAI;AACzB,QAAI+Q,OAAO,GAAG,KAAd;;AAEA,YAAQ/Q,CAAC,CAAChC,GAAV;AACE,WAAKxB,IAAI,CAACgb,IAAV;AACE,YAAIlO,MAAJ,EAAY;AACV6N,UAAAA,OAAO,CAAC5P,OAAR,CAAgB6B,KAAhB;AACAK,UAAAA,UAAU,CAAC,KAAD,CAAV;AACAsH,UAAAA,OAAO,GAAG,IAAV;AACD;;AAED;;AAEF,WAAKvU,IAAI,CAAC0a,KAAV;AACE,YAAI,CAAC5N,MAAL,EAAayH,OAAO,GAAG,IAAV;AACb;AAZJ;;AAeA,QAAIA,OAAJ,EAAa;AACX/Q,MAAAA,CAAC,CAACqR,cAAF;AACArR,MAAAA,CAAC,CAACsR,eAAF;AACD;AACF,GAtBD;;AAwBA,QAAMmG,WAAW,GAAGzX,CAAC,IAAI;AACvB,QAAI,CAACoG,QAAL,EAAe;AACfM,IAAAA,OAAO,CAAC1G,CAAD,CAAP;;AAEA,YAAQA,CAAC,CAAChC,GAAV;AACE,WAAKxB,IAAI,CAACyJ,KAAV;AACA,WAAKzJ,IAAI,CAAC0J,KAAV;AACA,WAAK1J,IAAI,CAAC0a,KAAV;AACE7M,QAAAA,QAAQ,CAACvN,cAAc,CAAC6T,KAAhB,CAAR;AACA;AALJ;AAOD,GAXD;;AAaAjW,EAAAA,SAAS,CAAC,MAAM,MAAMyO,YAAY,CAACT,SAAS,CAACnB,OAAX,CAAzB,EAA8C,EAA9C,CAAT;AACA7M,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIgL,UAAU,IAAI6C,YAAlB,EAAgC;AAC9B4O,MAAAA,OAAO,CAAC5P,OAAR,CAAgB6B,KAAhB;AACD,KAFD,MAEO;AACLK,MAAAA,UAAU,CAAC,KAAD,CAAV;AACD;AACF,GANQ,EAMN,CAAC/D,UAAD,EAAa6C,YAAb,EAA2BkB,UAA3B,CANM,CAAT;AAOA/O,EAAAA,SAAS,CAAC,MAAM;AACd+N,IAAAA,QAAQ,CAAC;AACPpG,MAAAA,IAAI,EAAEiH,MAAM,GAAG1M,kBAAkB,CAAC4X,IAAtB,GAA6B5X,kBAAkB,CAAC6X;AADrD,KAAD,CAAR;AAGD,GAJQ,EAIN,CAAChM,QAAD,EAAWa,MAAX,CAJM,CAAT;AAKAD,EAAAA,aAAa,CAACrE,YAAD,EAAesE,MAAf,CAAb;AACAxO,EAAAA,mBAAmB,CAACiK,WAAD,EAAc,OAAO;AACtCsF,IAAAA,QAAQ,EAAE,CAAC,GAAGzL,IAAJ,KAAa;AACrB,UAAI2J,YAAJ,EAAkB;AAChBI,QAAAA,QAAQ;AACR0B,QAAAA,QAAQ,CAAC,GAAGzL,IAAJ,CAAR;AACD;AACF,KANqC;AAOtC0X,IAAAA,SAAS,EAAE,MAAM;AACf,UAAIhN,MAAJ,EAAY;AACV6N,QAAAA,OAAO,CAAC5P,OAAR,CAAgB6B,KAAhB;AACAK,QAAAA,UAAU,CAAC,KAAD,CAAV;AACD;AACF;AAZqC,GAAP,CAAd,CAAnB;AAcA,QAAMvC,SAAS,GAAG1M,OAAO,CAAC,MAAMiC,MAAM,CAACC,MAAP,CAAc;AAC5CsH,IAAAA,IAAI,EAAEsF,MADsC;AAE5CoO,IAAAA,KAAK,EAAEhS,UAFqC;AAG5CI,IAAAA,MAAM,EAAEM,QAHoC;AAI5C9D,IAAAA,QAAQ,EAAEb;AAJkC,GAAd,CAAP,EAKrB,CAAC6H,MAAD,EAAS5D,UAAT,EAAqBU,QAArB,EAA+B3E,UAA/B,CALqB,CAAzB;AAMA,QAAM;AACJ6D,IAAAA,GAAG,EAAEqS,eADD;AAEJ1U,IAAAA,SAAS,EAAE2U,aAFP;AAGJ7P,IAAAA,MAAM,EAAE8P,UAHJ;AAIJ,OAAGC;AAJC,MAKFhB,SALJ;AAMA,QAAMiB,YAAY,GAAGvY,kBAAkB,CAAC,EAAE,GAAGyX,mBAAL;AACtCnO,IAAAA,YAAY,EAAEwO,gBADwB;AAEtCtO,IAAAA,YAAY,EAAEuO,gBAFwB;AAGtCS,IAAAA,WAAW,EAAErP,QAHyB;AAItCyN,IAAAA,OAAO,EAAErB,WAJ6B;AAKtCrO,IAAAA,OAAO,EAAE+Q;AAL6B,GAAD,EAMpCK,aANoC,CAAvC;;AAQA,QAAMG,WAAW,GAAG,MAAM;AACxB,UAAMtC,QAAQ,GAAG,aAAazb,KAAK,CAACqL,aAAN,CAAoB2I,QAApB,EAA8BzR,MAAM,CAAC+I,MAAP,CAAc,EAAd,EAAkBgF,SAAlB,EAA6BwM,eAA7B,EAA8C;AACxGvZ,MAAAA,KAAK,EAAEA,KADiG;AAExG0Q,MAAAA,SAAS,EAAEA,SAAS,KAAK,OAAOwI,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,SAAzC,CAFoF;AAGxG5I,MAAAA,SAAS,EAAEoJ,OAH6F;AAIxGvM,MAAAA,YAAY,EAAEmM,QAAQ,GAAG3H,WAAH,GAAiBxE,YAJiE;AAKxG4D,MAAAA,kBAAkB,EAAEuI,QAAQ,IAAIpD,aALwE;AAMxGlS,MAAAA,UAAU,EAAEA;AAN4F,KAA9C,CAA9B,CAA9B;AAQA,WAAOsV,QAAQ,GAAG,aAAa7b,YAAY,CAACya,QAAD,EAAWvG,WAAW,CAAC7H,OAAvB,CAA5B,GAA8DoO,QAA7E;AACD,GAVD;;AAYA,SAAO,aAAazb,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B;AAC5CtC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAEpL,YAFO;AAGhBoH,MAAAA;AAHgB,KAAD,CAD2B;AAM5CoR,IAAAA,IAAI,EAAE,cANsC;AAO5C/O,IAAAA,GAAG,EAAEsF,YAPuC;AAQ5CpE,IAAAA,SAAS,EAAEsK;AARiC,GAA1B,EASjB,aAAa5W,KAAK,CAACqL,aAAN,CAAoB,KAApB,EAA2B9I,MAAM,CAAC+I,MAAP,CAAc;AACvD6O,IAAAA,IAAI,EAAE,UADiD;AAEvD,qBAAiB,IAFsC;AAGvD,qBAAiB/K,MAHsC;AAIvD,qBAAiB7H,UAAU,IAAIC,SAJwB;AAKvD4S,IAAAA,QAAQ,EAAE5O,UAAU,IAAI,CAAC4D,MAAf,GAAwB,CAAxB,GAA4B,CAAC;AALgB,GAAd,EAMxCwO,aANwC,EAMzBC,YANyB,EAMX;AAC9BzS,IAAAA,GAAG,EAAEkC,cAAc,CAACmQ,eAAD,EAAkBR,OAAlB,CADW;AAE9BlU,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAExL,aAFO;AAGhByL,MAAAA,SAHgB;AAIhBjE,MAAAA,SAAS,EAAE2U;AAJK,KAAD,CAFa;AAQ9B5P,IAAAA,KAAK,EAAEF,aAAa,CAAC+P,UAAD,EAAa3Q,SAAb;AARU,GANW,CAA3B,EAeZ1M,OAAO,CAAC,MAAMkE,QAAQ,CAACiY,KAAD,EAAQzP,SAAR,CAAf,EAAmC,CAACyP,KAAD,EAAQzP,SAAR,CAAnC,CAfK,CATI,EAwBgDzJ,KAAK,IAAIwa,WAAW,EAxBpE,CAApB;AAyBD,CA1N8C,CAAnB,EA0NxB,SA1NwB,CAA5B;AA2NAvB,OAAO,CAACjM,SAAR,GAAoB,EAAE,GAAGzH,aAAL;AAClB,KAAG8B,yBADe;AAElBxC,EAAAA,QAAQ,EAAEnH,SAAS,CAACgI,IAFF;AAGlBwT,EAAAA,KAAK,EAAExb,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC0F,IAAX,EAAiB1F,SAAS,CAAC2H,IAA3B,CAApB,CAHW;AAIlBgU,EAAAA,SAAS,EAAE3b,SAAS,CAAC+c,KAAV,CAAgB,EAAE,GAAGvV,cAAc;AAAnB,GAAhB;AAJO,CAApB;AAOA+T,OAAO,CAACd,YAAR,GAAuB,EAAE,GAAG3Q,gBAAL;AACrBxB,EAAAA,SAAS,EAAE;AADU,CAAvB;AAIA,MAAM0U,QAAQ,GAAGhT,YAAY,EAAE,aAAapK,IAAI,CAAC,SAASod,QAAT,CAAkB;AACjElV,EAAAA,SADiE;AAEjE8E,EAAAA,MAFiE;AAGjE9I,EAAAA,KAHiE;AAIjEmZ,EAAAA,IAJiE;AAKjE/V,EAAAA,IALiE;AAMjEgW,EAAAA,OANiE;AAOjE/V,EAAAA,QAPiE;AAQjEd,EAAAA,KARiE;AASjEO,EAAAA,QATiE;AAUjEqU,EAAAA,OAViE;AAWjE1Q,EAAAA,UAXiE;AAYjED,EAAAA,WAZiE;AAajE,KAAG+E;AAb8D,CAAlB,EAc9C;AACD,QAAM/I,UAAU,GAAG,CAAC,CAACa,QAArB;AACAf,EAAAA,aAAa,CAACC,KAAD,EAAQC,UAAR,EAAoBM,QAApB,CAAb;AACA,QAAMuD,GAAG,GAAG3K,MAAM,EAAlB;AACA,QAAM;AACJgO,IAAAA,QADI;AAEJhC,IAAAA,MAFI;AAGJmC,IAAAA,YAHI;AAIJE,IAAAA;AAJI,MAKFV,YAAY,CAAChD,GAAD,EAAM9D,KAAN,EAAakE,UAAb,EAAyBjE,UAAzB,CALhB;AAMA,QAAMqT,aAAa,GAAGxa,UAAU,CAAC8B,oBAAD,CAAhC;AACA,QAAMkc,UAAU,GAAGhe,UAAU,CAAC+B,iBAAD,CAA7B;AACA,QAAM;AACJ+J,IAAAA,QADI;AAEJM,IAAAA,OAFI;AAGJC,IAAAA,MAAM,EAAE4R,eAHJ;AAIJ,OAAGtB;AAJC,MAKFrR,cAAc,CAACF,UAAD,EAAajE,UAAb,CALlB;AAMA,QAAM+W,OAAO,GAAGnW,IAAI,KAAK,OAAzB;AACA,QAAMoW,UAAU,GAAGpW,IAAI,KAAK,UAA5B;AACA,QAAMqW,QAAQ,GAAG,CAAC,CAACN,IAAF,IAAU,CAAC3W,UAAX,IAAyB,CAAC+W,OAA1B,IAAqC,CAACC,UAAvD;AACA,QAAME,SAAS,GAAGH,OAAO,GAAGF,UAAU,CAACrZ,KAAX,KAAqBA,KAAxB,GAAgCwZ,UAAU,GAAG,CAAC,CAACJ,OAAL,GAAe,KAAlF;;AAEA,QAAMtD,WAAW,GAAG/U,CAAC,IAAI;AACvB,QAAIyB,UAAJ,EAAgB;AAChB,UAAMuT,KAAK,GAAG;AACZ/V,MAAAA,KADY;AAEZ2Z,MAAAA,cAAc,EAAE5Y;AAFJ,KAAd;AAIA,QAAIA,CAAC,CAAChC,GAAF,KAAU0D,SAAd,EAAyBsT,KAAK,CAAChX,GAAN,GAAYgC,CAAC,CAAChC,GAAd;AACzB,QAAIya,UAAJ,EAAgBzD,KAAK,CAACqD,OAAN,GAAgB,CAACM,SAAjB;;AAEhB,QAAIH,OAAJ,EAAa;AACXxD,MAAAA,KAAK,CAACvW,IAAN,GAAa6Z,UAAU,CAAC7Z,IAAxB;AACAC,MAAAA,QAAQ,CAAC4Z,UAAU,CAACO,aAAZ,EAA2B7D,KAA3B,CAAR;AACD;;AAED,QAAI,CAACA,KAAK,CAAC1D,eAAX,EAA4B5S,QAAQ,CAAC0X,OAAD,EAAUpB,KAAV,CAAR;AAC5BF,IAAAA,aAAa,CAACC,WAAd,CAA0BC,KAA1B,EAAiCyD,UAAU,IAAID,OAA/C;AACD,GAhBD;;AAkBA,QAAMf,WAAW,GAAGzX,CAAC,IAAI;AACvB,QAAI,CAACoG,QAAL,EAAe;AACfM,IAAAA,OAAO,CAAC1G,CAAD,CAAP;;AAEA,YAAQA,CAAC,CAAChC,GAAV;AACE,WAAKxB,IAAI,CAACyJ,KAAV;AACA,WAAKzJ,IAAI,CAAC0J,KAAV;AACE,YAAIwS,QAAJ,EAAc;AACZpT,UAAAA,GAAG,CAACiC,OAAJ,CAAYuR,KAAZ;AACD,SAFD,MAEO;AACL/D,UAAAA,WAAW,CAAC/U,CAAD,CAAX;AACD;;AAED;AATJ;AAWD,GAfD;;AAiBA,QAAMuV,UAAU,GAAGvV,CAAC,IAAI;AACtBuY,IAAAA,eAAe,CAACvY,CAAD,CAAf;AACA2G,IAAAA,MAAM,CAAC3G,CAAD,CAAN;AACD,GAHD;;AAKA,QAAMkH,SAAS,GAAG1M,OAAO,CAAC,MAAMiC,MAAM,CAACC,MAAP,CAAc;AAC5C2F,IAAAA,IAD4C;AAE5CC,IAAAA,QAAQ,EAAEb,UAFkC;AAG5CiW,IAAAA,KAAK,EAAEhS,UAHqC;AAI5CI,IAAAA,MAAM,EAAEM,QAJoC;AAK5CiS,IAAAA,OAAO,EAAEM,SALmC;AAM5CI,IAAAA,MAAM,EAAEL;AANoC,GAAd,CAAP,EAOrB,CAACrW,IAAD,EAAOZ,UAAP,EAAmBiE,UAAnB,EAA+BU,QAA/B,EAAyCuS,SAAzC,EAAoDD,QAApD,CAPqB,CAAzB;AAQA,QAAMjZ,QAAQ,GAAGD,kBAAkB,CAAC,EAAE,GAAGyX,mBAAL;AAClCnO,IAAAA,YADkC;AAElCE,IAAAA,YAFkC;AAGlCgP,IAAAA,WAAW,EAAErP,QAHqB;AAIlCjC,IAAAA,OAAO,EAAE+Q,WAJyB;AAKlC9Q,IAAAA,MAAM,EAAE4O,UAL0B;AAMlCa,IAAAA,OAAO,EAAErB;AANyB,GAAD,EAOhCvK,SAPgC,CAAnC;AAQA,QAAMwO,aAAa,GAAG;AACpB3E,IAAAA,IAAI,EAAEmE,OAAO,GAAG,eAAH,GAAqBC,UAAU,GAAG,kBAAH,GAAwB,UADhD;AAEpB,oBAAgBD,OAAO,IAAIC,UAAX,GAAwBE,SAAxB,GAAoCjX,SAFhC;AAGpB,qBAAiBD,UAAU,IAAIC,SAHX;AAIpB4S,IAAAA,QAAQ,EAAE5O,UAAU,GAAG,CAAH,GAAO,CAAC,CAJR;AAKpB,OAAG8E,SALiB;AAMpB,OAAG/K,QANiB;AAOpB6F,IAAAA,GAAG,EAAEkC,cAAc,CAAC/B,WAAD,EAAcH,GAAd,CAPC;AAQpBrC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAExL,aAFO;AAGhByL,MAAAA,SAHgB;AAIhBjE,MAAAA;AAJgB,KAAD,CARG;AAcpB+E,IAAAA,KAAK,EAAEF,aAAa,CAACC,MAAD,EAASb,SAAT;AAdA,GAAtB;AAgBA,QAAM+R,cAAc,GAAGze,OAAO,CAAC,MAAMkE,QAAQ,CAACqD,QAAD,EAAWmF,SAAX,CAAf,EAAsC,CAACnF,QAAD,EAAWmF,SAAX,CAAtC,CAA9B;;AAEA,MAAIwR,QAAJ,EAAc;AACZ,WAAO,aAAaxe,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B;AAC5C8O,MAAAA,IAAI,EAAE;AADsC,KAA1B,EAEjB,aAAana,KAAK,CAACqL,aAAN,CAAoB,GAApB,EAAyB9I,MAAM,CAAC+I,MAAP,CAAc,EAAd,EAAkBwT,aAAlB,EAAiC;AACxEZ,MAAAA,IAAI,EAAEA;AADkE,KAAjC,CAAzB,EAEZa,cAFY,CAFI,CAApB;AAKD,GAND,MAMO;AACL,WAAO,aAAa/e,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0ByT,aAA1B,EAAyCC,cAAzC,CAApB;AACD;AACF,CAxH+C,CAAnB,EAwHzB,UAxHyB,CAA7B;AAyHAd,QAAQ,CAAC1N,SAAT,GAAqB,EAAE,GAAG9H,cAAc,EAAnB;AACnB1D,EAAAA,KAAK,EAAE9D,SAAS,CAAC+d,GADE;AAEnBd,EAAAA,IAAI,EAAEjd,SAAS,CAAC0H,MAFG;AAGnBR,EAAAA,IAAI,EAAElH,SAAS,CAACqI,KAAV,CAAgB,CAAC,UAAD,EAAa,OAAb,CAAhB,CAHa;AAInB6U,EAAAA,OAAO,EAAEld,SAAS,CAACgI,IAJA;AAKnBb,EAAAA,QAAQ,EAAEnH,SAAS,CAACgI,IALD;AAMnBpB,EAAAA,QAAQ,EAAE5G,SAAS,CAACyH,SAAV,CAAoB,CAACzH,SAAS,CAAC0F,IAAX,EAAiB1F,SAAS,CAAC2H,IAA3B,CAApB,CANS;AAOnBsT,EAAAA,OAAO,EAAEjb,SAAS,CAAC2H;AAPA,CAArB;AAUA,MAAMqW,aAAa,GAAGhU,YAAY,EAAE,aAAapK,IAAI,CAAC,SAASoe,aAAT,CAAuB;AAC3ElW,EAAAA,SAD2E;AAE3E8E,EAAAA,MAF2E;AAG3EzF,EAAAA,QAH2E;AAI3Ed,EAAAA,KAJ2E;AAK3EO,EAAAA,QAL2E;AAM3E2D,EAAAA,UAN2E;AAO3ED,EAAAA,WAP2E;AAQ3E,KAAG+E;AARwE,CAAvB,EASnD;AACD,QAAM/I,UAAU,GAAG,CAAC,CAACa,QAArB;AACAf,EAAAA,aAAa,CAACC,KAAD,EAAQC,UAAR,EAAoBM,QAApB,CAAb;AACA,QAAMuD,GAAG,GAAG3K,MAAM,CAAC,IAAD,CAAlB;AACA,QAAM;AACJgO,IAAAA,QADI;AAEJhC,IAAAA,MAFI;AAGJmC,IAAAA,YAHI;AAIJE,IAAAA;AAJI,MAKFV,YAAY,CAAChD,GAAD,EAAM9D,KAAN,EAAakE,UAAb,EAAyBjE,UAAzB,CALhB;AAMA,QAAM;AACJ2T,IAAAA;AADI,MAEF9a,UAAU,CAAC8B,oBAAD,CAFd;AAGA,QAAM8K,SAAS,GAAG1M,OAAO,CAAC,MAAMiC,MAAM,CAACC,MAAP,CAAc;AAC5C4F,IAAAA,QAAQ,EAAEb,UADkC;AAE5CiW,IAAAA,KAAK,EAAEhS,UAFqC;AAG5C0T,IAAAA,SAAS,EAAE;AAHiC,GAAd,CAAP,EAIrB,CAAC3X,UAAD,EAAaiE,UAAb,CAJqB,CAAzB;AAKA,QAAMuT,cAAc,GAAGze,OAAO,CAAC,MAAMkE,QAAQ,CAACqD,QAAD,EAAW,EAAE,GAAGmF,SAAL;AACtD5B,IAAAA,GADsD;AAEtDgR,IAAAA,SAAS,EAAElB;AAF2C,GAAX,CAAf,EAG1B,CAACrT,QAAD,EAAWmF,SAAX,EAAsBkO,WAAtB,CAH0B,CAA9B;AAIA,QAAM3V,QAAQ,GAAGD,kBAAkB,CAAC;AAClCsJ,IAAAA,YADkC;AAElCE,IAAAA,YAAY,EAAEhJ,CAAC,IAAIgJ,YAAY,CAAChJ,CAAD,EAAI,IAAJ,CAFG;AAGlCqZ,IAAAA,OAAO,EAAE1Q,QAHyB;AAIlChC,IAAAA;AAJkC,GAAD,EAKhC6D,SALgC,CAAnC;AAMA,SAAO,aAAatQ,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B9I,MAAM,CAAC+I,MAAP,CAAc;AAC1D,qBAAiB/D,UAAU,IAAIC,SAD2B;AAE1D2S,IAAAA,IAAI,EAAE,UAFoD;AAG1DC,IAAAA,QAAQ,EAAE;AAHgD,GAAd,EAI3C9J,SAJ2C,EAIhC/K,QAJgC,EAItB;AACtB6F,IAAAA,GAAG,EAAEG,WADiB;AAEtBxC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAExL,aAFO;AAGhByL,MAAAA,SAHgB;AAIhBjE,MAAAA;AAJgB,KAAD,CAFK;AAQtB+E,IAAAA,KAAK,EAAEF,aAAa,CAACC,MAAD,EAASb,SAAT;AARE,GAJsB,CAA1B,EAahB+R,cAbgB,CAApB;AAcD,CAnDoD,CAAnB,EAmD9B,eAnD8B,CAAlC;AAoDAE,aAAa,CAAC1O,SAAd,GAA0B,EAAE,GAAG9H,cAAc,EAAnB;AACxBL,EAAAA,QAAQ,EAAEnH,SAAS,CAACgI,IADI;AAExBpB,EAAAA,QAAQ,EAAE5G,SAAS,CAAC2H;AAFI,CAA1B;AAKA,MAAMwW,WAAW,GAAG,aAAave,IAAI,EAAE,aAAaV,UAAU,CAAC,SAASif,WAAT,CAAqB;AAClFrW,EAAAA,SADkF;AAElF8E,EAAAA,MAFkF;AAGlF,KAAGyC;AAH+E,CAArB,EAI5D/E,WAJ4D,EAI/C;AACd,SAAO,aAAavL,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B9I,MAAM,CAAC+I,MAAP,CAAc;AAC1D6O,IAAAA,IAAI,EAAE;AADoD,GAAd,EAE3C7J,SAF2C,EAEhC;AACZlF,IAAAA,GAAG,EAAEG,WADO;AAEZxC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAEvL,gBAFO;AAGhBuH,MAAAA;AAHgB,KAAD,CAFL;AAOZ+E,IAAAA,KAAK,EAAEF,aAAa,CAACC,MAAD;AAPR,GAFgC,CAA1B,CAApB;AAWD,CAhB6D,CAAzB,CAArC;AAiBAuR,WAAW,CAAC7O,SAAZ,GAAwB,EAAE,GAAG9H,cAAc;AAAnB,CAAxB;AAGA,MAAM4W,UAAU,GAAG,aAAaxe,IAAI,EAAE,aAAaV,UAAU,CAAC,SAASkf,UAAT,CAAoB;AAChFtW,EAAAA,SADgF;AAEhF8E,EAAAA,MAFgF;AAGhF,KAAGyC;AAH6E,CAApB,EAI3D/E,WAJ2D,EAI9C;AACd,SAAO,aAAavL,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B9I,MAAM,CAAC+I,MAAP,CAAc;AAC1D6O,IAAAA,IAAI,EAAE;AADoD,GAAd,EAE3C7J,SAF2C,EAEhC;AACZlF,IAAAA,GAAG,EAAEG,WADO;AAEZxC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAEtL,eAFO;AAGhBsH,MAAAA;AAHgB,KAAD,CAFL;AAOZ+E,IAAAA,KAAK,EAAEF,aAAa,CAACC,MAAD;AAPR,GAFgC,CAA1B,CAApB;AAWD,CAhB4D,CAAzB,CAApC;AAiBAwR,UAAU,CAAC9O,SAAX,GAAuB,EAAE,GAAG9H,cAAc;AAAnB,CAAvB;AAGA,MAAM6W,SAAS,GAAGza,UAAU,EAAE,aAAa1E,UAAU,CAAC,SAASmf,SAAT,CAAmB;AACvEvW,EAAAA,SADuE;AAEvE8E,EAAAA,MAFuE;AAGvEtF,EAAAA,YAHuE;AAIvE,KAAG+H;AAJoE,CAAnB,EAKnD/E,WALmD,EAKtC;AACd,QAAMH,GAAG,GAAG3K,MAAM,CAAC,IAAD,CAAlB;AACA,QAAM,CAACoZ,cAAD,EAAiB0F,iBAAjB,IAAsClf,QAAQ,EAApD;AACA,QAAM;AACJyG,IAAAA,QADI;AAEJ2Q,IAAAA;AAFI,MAGFrX,UAAU,CAAC6B,eAAD,CAHd;AAIAkM,EAAAA,yBAAyB,CAAC,MAAM;AAC9B,QAAIwL,SAAJ;;AAEA,QAAIpR,YAAY,IAAIkP,WAAW,IAAI,CAAnC,EAAsC;AACpCkC,MAAAA,SAAS,GAAGvO,GAAG,CAACiC,OAAJ,CAAYwD,qBAAZ,GAAoCa,MAApC,GAA6C+F,WAAzD;AACA,UAAIkC,SAAS,GAAG,CAAhB,EAAmBA,SAAS,GAAG,CAAZ;AACpB;;AAED4F,IAAAA,iBAAiB,CAAC5F,SAAS,IAAI,CAAb,GAAiB;AACjCA,MAAAA,SADiC;AAEjC7S,MAAAA;AAFiC,KAAjB,GAGdU,SAHa,CAAjB;AAID,GAZwB,EAYtB,CAACe,YAAD,EAAezB,QAAf,EAAyB2Q,WAAzB,CAZsB,CAAzB;AAaAtJ,EAAAA,yBAAyB,CAAC,MAAM;AAC9B,QAAI0L,cAAJ,EAAoBzO,GAAG,CAACiC,OAAJ,CAAYsK,SAAZ,GAAwB,CAAxB;AACrB,GAFwB,EAEtB,CAACkC,cAAD,CAFsB,CAAzB;AAGA,SAAO,aAAa7Z,KAAK,CAACqL,aAAN,CAAoB,KAApB,EAA2B9I,MAAM,CAAC+I,MAAP,CAAc,EAAd,EAAkBgF,SAAlB,EAA6B;AAC1ElF,IAAAA,GAAG,EAAEkC,cAAc,CAAC/B,WAAD,EAAcH,GAAd,CADuD;AAE1ErC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAErL,cAFO;AAGhBqH,MAAAA;AAHgB,KAAD,CAFyD;AAO1E+E,IAAAA,KAAK,EAAE,EAAE,GAAGF,aAAa,CAACC,MAAD,CAAlB;AACL,SAAGgM;AADE;AAPmE,GAA7B,CAA3B,CAApB;AAWD,CAvCoD,CAAzB,EAuCxB,WAvCwB,CAA5B;AAwCAyF,SAAS,CAAC/O,SAAV,GAAsB,EAAE,GAAG9H,cAAc,EAAnB;AACpBF,EAAAA,YAAY,EAAEtH,SAAS,CAACgI;AADJ,CAAtB;AAIA,MAAMuW,cAAc,GAAG3a,UAAU,EAAE,aAAa1E,UAAU,CAAC,SAASqf,cAAT,CAAwB;AACjF,gBAAcvL,SADmE;AAEjFlL,EAAAA,SAFiF;AAGjF8E,EAAAA,MAHiF;AAIjFtJ,EAAAA,IAJiF;AAKjFQ,EAAAA,KALiF;AAMjF4Z,EAAAA,aANiF;AAOjF,KAAGrO;AAP8E,CAAxB,EAQxD/E,WARwD,EAQ3C;AACd,QAAMkU,YAAY,GAAGnf,OAAO,CAAC,OAAO;AAClCiE,IAAAA,IADkC;AAElCQ,IAAAA,KAFkC;AAGlC4Z,IAAAA;AAHkC,GAAP,CAAD,EAIxB,CAACpa,IAAD,EAAOQ,KAAP,EAAc4Z,aAAd,CAJwB,CAA5B;AAKA,SAAO,aAAa3e,KAAK,CAACqL,aAAN,CAAoBlJ,iBAAiB,CAACkY,QAAtC,EAAgD;AAClEtV,IAAAA,KAAK,EAAE0a;AAD2D,GAAhD,EAEjB,aAAazf,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B;AACxC8O,IAAAA,IAAI,EAAE;AADkC,GAA1B,EAEb,aAAana,KAAK,CAACqL,aAAN,CAAoB,IAApB,EAA0B9I,MAAM,CAAC+I,MAAP,CAAc;AACtD6O,IAAAA,IAAI,EAAE,OADgD;AAEtD,kBAAclG,SAAS,IAAI1P,IAAb,IAAqB;AAFmB,GAAd,EAGvC+L,SAHuC,EAG5B;AACZlF,IAAAA,GAAG,EAAEG,WADO;AAEZxC,IAAAA,SAAS,EAAE8D,MAAM,CAAC;AAChBC,MAAAA,KAAK,EAAE1L,SADS;AAEhB2L,MAAAA,OAAO,EAAEnL,eAFO;AAGhBmH,MAAAA;AAHgB,KAAD,CAFL;AAOZ+E,IAAAA,KAAK,EAAEF,aAAa,CAACC,MAAD;AAPR,GAH4B,CAA1B,CAFA,CAFI,CAApB;AAgBD,CA9ByD,CAAzB,EA8B7B,gBA9B6B,CAAjC;AA+BA2R,cAAc,CAACjP,SAAf,GAA2B,EAAE,GAAG9H,cAAc,EAAnB;AACzBlE,EAAAA,IAAI,EAAEtD,SAAS,CAAC0H,MADS;AAEzB5D,EAAAA,KAAK,EAAE9D,SAAS,CAAC+d,GAFQ;AAGzBL,EAAAA,aAAa,EAAE1d,SAAS,CAAC2H;AAHA,CAA3B;AAMA,SAAS4R,cAAT,EAAyByE,aAAzB,EAAwCtD,IAAxC,EAA8CtL,UAA9C,EAA0D+O,WAA1D,EAAuEE,SAAvE,EAAkFD,UAAlF,EAA8FpB,QAA9F,EAAwGuB,cAAxG,EAAwHhD,OAAxH,EAAiIvX,QAAjI,EAA2IE,YAA3I,EAAyJmK,YAAzJ","sourcesContent":["import React, { Children, cloneElement, forwardRef, useContext, useState, useMemo, useLayoutEffect, useEffect, useRef, useReducer, useCallback, useImperativeHandle, memo } from 'react';\nimport ReactDOM, { unstable_batchedUpdates, createPortal } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { useTransition } from 'react-transition-state';\n\nconst menuContainerClass = 'szh-menu-container';\nconst menuClass = 'szh-menu';\nconst menuButtonClass = 'szh-menu-button';\nconst menuArrowClass = 'arrow';\nconst menuItemClass = 'item';\nconst menuDividerClass = 'divider';\nconst menuHeaderClass = 'header';\nconst menuGroupClass = 'group';\nconst subMenuClass = 'submenu';\nconst radioGroupClass = 'radio-group';\nconst initialHoverIndex = -1;\nconst HoverIndexContext = /*#__PURE__*/React.createContext(initialHoverIndex);\nconst MenuListItemContext = /*#__PURE__*/React.createContext({});\nconst MenuListContext = /*#__PURE__*/React.createContext({});\nconst EventHandlersContext = /*#__PURE__*/React.createContext({});\nconst RadioGroupContext = /*#__PURE__*/React.createContext({});\nconst SettingsContext = /*#__PURE__*/React.createContext({});\nconst ItemSettingsContext = /*#__PURE__*/React.createContext({});\nconst Keys = Object.freeze({\n  'ENTER': 'Enter',\n  'ESC': 'Escape',\n  'SPACE': ' ',\n  'HOME': 'Home',\n  'END': 'End',\n  'LEFT': 'ArrowLeft',\n  'RIGHT': 'ArrowRight',\n  'UP': 'ArrowUp',\n  'DOWN': 'ArrowDown'\n});\nconst HoverIndexActionTypes = Object.freeze({\n  'RESET': 'HOVER_RESET',\n  'SET': 'HOVER_SET',\n  'UNSET': 'HOVER_UNSET',\n  'INCREASE': 'HOVER_INCREASE',\n  'DECREASE': 'HOVER_DECREASE',\n  'FIRST': 'HOVER_FIRST',\n  'LAST': 'HOVER_LAST'\n});\nconst SubmenuActionTypes = Object.freeze({\n  'OPEN': 'SUBMENU_OPEN',\n  'CLOSE': 'SUBMENU_CLOSE'\n});\nconst CloseReason = Object.freeze({\n  'CLICK': 'click',\n  'CANCEL': 'cancel',\n  'BLUR': 'blur',\n  'SCROLL': 'scroll'\n});\nconst FocusPositions = Object.freeze({\n  'INITIAL': 'initial',\n  'FIRST': 'first',\n  'LAST': 'last'\n});\nconst MenuStateMap = Object.freeze({\n  entering: 'opening',\n  entered: 'open',\n  exiting: 'closing',\n  exited: 'closed'\n});\n\nconst isProd = process.env.NODE_ENV === 'production';\nconst isMenuOpen = state => !!state && state[0] === 'o';\nconst batchedUpdates = unstable_batchedUpdates || (callback => callback());\nconst values = Object.values || (obj => Object.keys(obj).map(key => obj[key]));\nconst floatEqual = (a, b, diff = 0.0001) => Math.abs(a - b) < diff;\nconst getTransition = (transition, name) => !!(transition && transition[name]) || transition === true;\nconst safeCall = (fn, ...args) => typeof fn === 'function' ? fn(...args) : fn;\nconst getName = component => component && component['_szhsinMenu'];\nconst defineName = (component, name) => name ? Object.defineProperty(component, '_szhsinMenu', {\n  value: name,\n  writable: false\n}) : component;\nconst applyHOC = HOC => (...args) => defineName(HOC(...args), getName(args[0]));\nconst applyStatics = sourceComponent => wrappedComponent => defineName(wrappedComponent, getName(sourceComponent));\nconst attachHandlerProps = (handlers, props) => {\n  if (!props) return handlers;\n  const result = {};\n\n  for (const handlerName of Object.keys(handlers)) {\n    const handler = handlers[handlerName];\n    const propHandler = props[handlerName];\n    let attachedHandler;\n\n    if (typeof propHandler === 'function') {\n      attachedHandler = e => {\n        propHandler(e);\n        handler(e);\n      };\n    } else {\n      attachedHandler = handler;\n    }\n\n    result[handlerName] = attachedHandler;\n  }\n\n  return result;\n};\nconst parsePadding = paddingStr => {\n  if (typeof paddingStr !== 'string') return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  const padding = paddingStr.trim().split(/\\s+/, 4).map(parseFloat);\n  const top = !isNaN(padding[0]) ? padding[0] : 0;\n  const right = !isNaN(padding[1]) ? padding[1] : top;\n  return {\n    top,\n    right,\n    bottom: !isNaN(padding[2]) ? padding[2] : top,\n    left: !isNaN(padding[3]) ? padding[3] : right\n  };\n};\nconst getScrollAncestor = node => {\n  while (node && node !== document.body) {\n    const {\n      overflow,\n      overflowX,\n      overflowY\n    } = getComputedStyle(node);\n    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) return node;\n    node = node.parentNode;\n  }\n\n  return window;\n};\nconst validateIndex = (index, isDisabled, node) => {\n  if (!isProd && index === undefined && !isDisabled) {\n    const error = `[React-Menu] Validate item '${node && node.toString()}' failed.\nYou're probably creating wrapping components or HOC over MenuItem, SubMenu or FocusableItem.\nTo create wrapping components, see: https://codesandbox.io/s/react-menu-wrapping-q0b59\nTo create HOCs, see: https://codesandbox.io/s/react-menu-hoc-0bipn`;\n    throw new Error(error);\n  }\n};\n\nconst cloneChildren = (children, startIndex = 0, inRadioGroup) => {\n  let index = startIndex;\n  let descendOverflow = false;\n  const items = Children.map(children, child => {\n    if (child === undefined || child === null) return null;\n    if (!child.type) return child;\n    const name = getName(child.type);\n\n    switch (name) {\n      case 'MenuItem':\n        {\n          if (inRadioGroup) {\n            const props = {\n              type: 'radio'\n            };\n            if (!child.props.disabled) props.index = index++;\n            return /*#__PURE__*/cloneElement(child, props);\n          }\n        }\n\n      case 'SubMenu':\n      case 'FocusableItem':\n        return child.props.disabled ? child : /*#__PURE__*/cloneElement(child, {\n          index: index++\n        });\n\n      default:\n        {\n          const innerChildren = child.props.children;\n          if (innerChildren === null || typeof innerChildren !== \"object\") return child;\n          const desc = cloneChildren(innerChildren, index, inRadioGroup || name === 'MenuRadioGroup');\n          index = desc.index;\n\n          if (name === 'MenuGroup') {\n            const takeOverflow = !!child.props.takeOverflow;\n            const descOverflow = desc.descendOverflow;\n            if (!isProd && (descendOverflow === descOverflow ? descOverflow : takeOverflow)) throw new Error('[React-Menu] Only one MenuGroup in a menu is allowed to have takeOverflow prop.');\n            descendOverflow = descendOverflow || descOverflow || takeOverflow;\n          }\n\n          return /*#__PURE__*/cloneElement(child, {\n            children: desc.items\n          });\n        }\n    }\n  });\n  return {\n    items,\n    index,\n    descendOverflow\n  };\n};\n\nconst stylePropTypes = name => ({\n  [name ? `${name}ClassName` : 'className']: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  [name ? `${name}Styles` : 'styles']: PropTypes.oneOfType([PropTypes.object, PropTypes.func])\n});\nconst menuPropTypes = {\n  className: PropTypes.string,\n  ...stylePropTypes('menu'),\n  ...stylePropTypes('arrow'),\n  arrow: PropTypes.bool,\n  offsetX: PropTypes.number,\n  offsetY: PropTypes.number,\n  align: PropTypes.oneOf(['start', 'center', 'end']),\n  direction: PropTypes.oneOf(['left', 'right', 'top', 'bottom']),\n  position: PropTypes.oneOf(['auto', 'anchor', 'initial']),\n  overflow: PropTypes.oneOf(['auto', 'visible', 'hidden'])\n};\nconst rootMenuPropTypes = { ...menuPropTypes,\n  containerProps: PropTypes.object,\n  initialMounted: PropTypes.bool,\n  unmountOnClose: PropTypes.bool,\n  transition: PropTypes.oneOfType([PropTypes.bool, PropTypes.exact({\n    open: PropTypes.bool,\n    close: PropTypes.bool,\n    item: PropTypes.bool\n  })]),\n  transitionTimeout: PropTypes.number,\n  boundingBoxRef: PropTypes.object,\n  boundingBoxPadding: PropTypes.string,\n  reposition: PropTypes.oneOf(['auto', 'initial']),\n  repositionFlag: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  viewScroll: PropTypes.oneOf(['auto', 'close', 'initial']),\n  submenuOpenDelay: PropTypes.number,\n  submenuCloseDelay: PropTypes.number,\n  portal: PropTypes.bool,\n  theming: PropTypes.string,\n  onItemClick: PropTypes.func\n};\nconst uncontrolledMenuPropTypes = {\n  instanceRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n  onMenuChange: PropTypes.func\n};\nconst menuDefaultProps = {\n  offsetX: 0,\n  offsetY: 0,\n  align: 'start',\n  direction: 'bottom',\n  position: 'auto',\n  overflow: 'visible'\n};\nconst rootMenuDefaultProps = { ...menuDefaultProps,\n  reposition: 'auto',\n  viewScroll: 'initial',\n  transitionTimeout: 200,\n  submenuOpenDelay: 300,\n  submenuCloseDelay: 150\n};\n\nconst withHovering = (WrapppedComponent, name) => {\n  const WithHovering = defineName( /*#__PURE__*/forwardRef((props, ref) => {\n    return /*#__PURE__*/React.createElement(WrapppedComponent, Object.assign({}, props, {\n      externalRef: ref,\n      isHovering: useContext(HoverIndexContext) === props.index\n    }));\n  }), name);\n  WithHovering.displayName = `WithHovering(${name})`;\n  return WithHovering;\n};\n\nconst useActiveState = (isHovering, isDisabled, ...moreKeys) => {\n  const [active, setActive] = useState(false);\n  const activeKeys = [Keys.ENTER, Keys.SPACE, ...moreKeys];\n\n  const cancelActive = () => active && setActive(false);\n\n  return {\n    isActive: active,\n    onPointerDown: () => {\n      if (!isDisabled) setActive(true);\n    },\n    onPointerUp: cancelActive,\n    onPointerLeave: cancelActive,\n    onKeyDown: e => {\n      if (!active && isHovering && !isDisabled && activeKeys.indexOf(e.key) !== -1) {\n        setActive(true);\n      }\n    },\n    onKeyUp: e => {\n      if (activeKeys.indexOf(e.key) !== -1) {\n        setActive(false);\n      }\n    },\n    onBlur: e => {\n      if (active && !e.currentTarget.contains(e.relatedTarget)) {\n        setActive(false);\n      }\n    }\n  };\n};\n\nconst useBEM = ({\n  block,\n  element,\n  modifiers,\n  className\n}) => useMemo(() => {\n  const blockElement = element ? `${block}__${element}` : block;\n  let classString = blockElement;\n\n  for (const name of Object.keys(modifiers || {})) {\n    const value = modifiers[name];\n\n    if (value) {\n      classString += ` ${blockElement}--`;\n      classString += value === true ? name : `${name}-${value}`;\n    }\n  }\n\n  let expandedClassName = typeof className === 'function' ? className(modifiers) : className;\n\n  if (typeof expandedClassName === 'string') {\n    expandedClassName = expandedClassName.trim();\n    if (expandedClassName) classString += ` ${expandedClassName}`;\n  }\n\n  return classString;\n}, [block, element, modifiers, className]);\n\nconst setRef = (ref, element) => {\n  if (typeof ref === 'function') {\n    ref(element);\n  } else if (ref) {\n    ref.current = element;\n  }\n};\n\nconst useCombinedRef = (refA, refB) => useMemo(() => {\n  if (!refA) return refB;\n  if (!refB) return refA;\n  return element => {\n    setRef(refA, element);\n    setRef(refB, element);\n  };\n}, [refA, refB]);\n\nconst isObject = obj => obj && typeof obj === 'object';\n\nconst sanitiseKey = key => key[0] === '$' ? key.slice(1) : key;\n\nconst useFlatStyles = (styles, modifiers) => useMemo(() => {\n  if (typeof styles === 'function') return styles(modifiers);\n  if (!isObject(styles)) return undefined;\n  if (!modifiers) return styles;\n  const style = {};\n\n  for (const prop of Object.keys(styles)) {\n    const value = styles[prop];\n\n    if (isObject(value)) {\n      const modifierValue = modifiers[sanitiseKey(prop)];\n\n      if (typeof modifierValue === 'string') {\n        for (const nestedProp of Object.keys(value)) {\n          const nestedValue = value[nestedProp];\n\n          if (isObject(nestedValue)) {\n            if (sanitiseKey(nestedProp) === modifierValue) {\n              Object.assign(style, nestedValue);\n            }\n          } else {\n            style[nestedProp] = nestedValue;\n          }\n        }\n      } else if (modifierValue) {\n        Object.assign(style, value);\n      }\n    } else {\n      style[prop] = value;\n    }\n  }\n\n  return style;\n}, [styles, modifiers]);\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nconst useItemState = (ref, index, isHovering, isDisabled) => {\n  const {\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const timeoutId = useRef();\n\n  const setHover = () => {\n    if (!isDisabled) dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n  };\n\n  const onBlur = e => {\n    if (isHovering && !e.currentTarget.contains(e.relatedTarget)) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const onMouseEnter = () => {\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(setHover, submenuCloseDelay);\n    } else {\n      setHover();\n    }\n  };\n\n  const onMouseLeave = (_, keepHover) => {\n    timeoutId.current && clearTimeout(timeoutId.current);\n    if (!keepHover) dispatch({\n      type: HoverIndexActionTypes.UNSET,\n      index\n    });\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      ref.current && ref.current.focus();\n    }\n  }, [ref, isHovering, isParentOpen]);\n  return {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  };\n};\n\nconst useMenuChange = (onMenuChange, isOpen) => {\n  const prevOpen = useRef(isOpen);\n  useEffect(() => {\n    if (prevOpen.current !== isOpen) safeCall(onMenuChange, {\n      open: isOpen\n    });\n    prevOpen.current = isOpen;\n  }, [onMenuChange, isOpen]);\n};\n\nconst useMenuState = ({\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout\n} = {}) => {\n  const [state, toggleMenu, endTransition] = useTransition({\n    mountOnEnter: !initialMounted,\n    unmountOnExit: unmountOnClose,\n    timeout: transitionTimeout,\n    enter: getTransition(transition, 'open'),\n    exit: getTransition(transition, 'close')\n  });\n  return {\n    state: MenuStateMap[state],\n    toggleMenu,\n    endTransition\n  };\n};\n\nconst useMenuStateAndFocus = options => {\n  const menuState = useMenuState(options);\n  const [menuItemFocus, setMenuItemFocus] = useState({});\n\n  const openMenu = (position, alwaysUpdate) => {\n    setMenuItemFocus({\n      position,\n      alwaysUpdate\n    });\n    menuState.toggleMenu(true);\n  };\n\n  return { ...menuState,\n    openMenu,\n    menuItemFocus\n  };\n};\n\nconst MenuButton = defineName( /*#__PURE__*/forwardRef(function MenuButton({\n  className,\n  styles,\n  isOpen,\n  disabled,\n  children,\n  ...restProps\n}, ref) {\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen\n  }), [isOpen]);\n  return /*#__PURE__*/React.createElement(\"button\", Object.assign({\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": disabled || undefined,\n    type: \"button\",\n    disabled: disabled\n  }, restProps, {\n    ref: ref,\n    className: useBEM({\n      block: menuButtonClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), children);\n}), 'MenuButton');\nMenuButton.propTypes = { ...stylePropTypes(),\n  isOpen: PropTypes.bool,\n  disabled: PropTypes.bool\n};\n\nconst getPositionHelpers = ({\n  menuRef,\n  containerRef,\n  scrollingRef,\n  boundingBoxPadding\n}) => {\n  const menuRect = menuRef.current.getBoundingClientRect();\n  const containerRect = containerRef.current.getBoundingClientRect();\n  const boundingRect = scrollingRef.current === window ? {\n    left: 0,\n    top: 0,\n    right: document.documentElement.clientWidth,\n    bottom: window.innerHeight\n  } : scrollingRef.current.getBoundingClientRect();\n  const padding = parsePadding(boundingBoxPadding);\n\n  const getLeftOverflow = x => x + containerRect.left - boundingRect.left - padding.left;\n\n  const getRightOverflow = x => x + containerRect.left + menuRect.width - boundingRect.right + padding.right;\n\n  const getTopOverflow = y => y + containerRect.top - boundingRect.top - padding.top;\n\n  const getBottomOverflow = y => y + containerRect.top + menuRect.height - boundingRect.bottom + padding.bottom;\n\n  const confineHorizontally = x => {\n    let leftOverflow = getLeftOverflow(x);\n\n    if (leftOverflow < 0) {\n      x -= leftOverflow;\n    } else {\n      const rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        x -= rightOverflow;\n        leftOverflow = getLeftOverflow(x);\n        if (leftOverflow < 0) x -= leftOverflow;\n      }\n    }\n\n    return x;\n  };\n\n  const confineVertically = y => {\n    let topOverflow = getTopOverflow(y);\n\n    if (topOverflow < 0) {\n      y -= topOverflow;\n    } else {\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        y -= bottomOverflow;\n        topOverflow = getTopOverflow(y);\n        if (topOverflow < 0) y -= topOverflow;\n      }\n    }\n\n    return y;\n  };\n\n  return {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  };\n};\n\nconst positionContextMenu = ({\n  positionHelpers,\n  anchorPoint\n}) => {\n  const {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  } = positionHelpers;\n  let x, y;\n  x = anchorPoint.x - containerRect.left;\n  y = anchorPoint.y - containerRect.top;\n  const rightOverflow = getRightOverflow(x);\n\n  if (rightOverflow > 0) {\n    const adjustedX = x - menuRect.width;\n    const leftOverflow = getLeftOverflow(adjustedX);\n\n    if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n      x = adjustedX;\n    }\n\n    x = confineHorizontally(x);\n  }\n\n  let computedDirection = 'bottom';\n  const bottomOverflow = getBottomOverflow(y);\n\n  if (bottomOverflow > 0) {\n    const adjustedY = y - menuRect.height;\n    const topOverflow = getTopOverflow(adjustedY);\n\n    if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n      y = adjustedY;\n      computedDirection = 'top';\n    }\n\n    y = confineVertically(y);\n  }\n\n  return {\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowVertical = ({\n  arrowRef,\n  menuY,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let y = anchorRect.top - containerRect.top - menuY + anchorRect.height / 2;\n  const offset = arrowRef.current.offsetHeight * 1.25;\n  y = Math.max(offset, y);\n  y = Math.min(y, menuRect.height - offset);\n  return y;\n};\n\nconst placeLeftorRight = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeLeftorRightY,\n  placeLeftX,\n  placeRightX,\n  getLeftOverflow,\n  getRightOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction;\n  let y = placeLeftorRightY;\n\n  if (position !== 'initial') {\n    y = confineVertically(y);\n\n    if (position === 'anchor') {\n      y = Math.min(y, anchorRect.bottom - containerRect.top);\n      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);\n    }\n  }\n\n  let x, leftOverflow, rightOverflow;\n\n  if (computedDirection === 'left') {\n    x = placeLeftX;\n\n    if (position !== 'initial') {\n      leftOverflow = getLeftOverflow(x);\n\n      if (leftOverflow < 0) {\n        rightOverflow = getRightOverflow(placeRightX);\n\n        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {\n          x = placeRightX;\n          computedDirection = 'right';\n        }\n      }\n    }\n  } else {\n    x = placeRightX;\n\n    if (position !== 'initial') {\n      rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        leftOverflow = getLeftOverflow(placeLeftX);\n\n        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n          x = placeLeftX;\n          computedDirection = 'left';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') x = confineHorizontally(x);\n  const arrowY = arrow ? placeArrowVertical({\n    menuY: y,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowY,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowHorizontal = ({\n  arrowRef,\n  menuX,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let x = anchorRect.left - containerRect.left - menuX + anchorRect.width / 2;\n  const offset = arrowRef.current.offsetWidth * 1.25;\n  x = Math.max(offset, x);\n  x = Math.min(x, menuRect.width - offset);\n  return x;\n};\n\nconst placeToporBottom = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeToporBottomX,\n  placeTopY,\n  placeBottomY,\n  getTopOverflow,\n  getBottomOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction === 'top' ? 'top' : 'bottom';\n  let x = placeToporBottomX;\n\n  if (position !== 'initial') {\n    x = confineHorizontally(x);\n\n    if (position === 'anchor') {\n      x = Math.min(x, anchorRect.right - containerRect.left);\n      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);\n    }\n  }\n\n  let y, topOverflow, bottomOverflow;\n\n  if (computedDirection === 'top') {\n    y = placeTopY;\n\n    if (position !== 'initial') {\n      topOverflow = getTopOverflow(y);\n\n      if (topOverflow < 0) {\n        bottomOverflow = getBottomOverflow(placeBottomY);\n\n        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {\n          y = placeBottomY;\n          computedDirection = 'bottom';\n        }\n      }\n    }\n  } else {\n    y = placeBottomY;\n\n    if (position !== 'initial') {\n      bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        topOverflow = getTopOverflow(placeTopY);\n\n        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n          y = placeTopY;\n          computedDirection = 'top';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') y = confineVertically(y);\n  const arrowX = arrow ? placeArrowHorizontal({\n    menuX: x,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowX,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst positionMenu = ({\n  arrow,\n  align,\n  direction,\n  offsetX,\n  offsetY,\n  position,\n  anchorRef,\n  arrowRef,\n  positionHelpers\n}) => {\n  const {\n    menuRect,\n    containerRect\n  } = positionHelpers;\n  let horizontalOffset = offsetX;\n  let verticalOffset = offsetY;\n\n  if (arrow) {\n    if (direction === 'left' || direction === 'right') {\n      horizontalOffset += arrowRef.current.offsetWidth;\n    } else {\n      verticalOffset += arrowRef.current.offsetHeight;\n    }\n  }\n\n  const anchorRect = anchorRef.current.getBoundingClientRect();\n  const placeLeftX = anchorRect.left - containerRect.left - menuRect.width - horizontalOffset;\n  const placeRightX = anchorRect.right - containerRect.left + horizontalOffset;\n  const placeTopY = anchorRect.top - containerRect.top - menuRect.height - verticalOffset;\n  const placeBottomY = anchorRect.bottom - containerRect.top + verticalOffset;\n  let placeToporBottomX, placeLeftorRightY;\n\n  if (align === 'end') {\n    placeToporBottomX = anchorRect.right - containerRect.left - menuRect.width;\n    placeLeftorRightY = anchorRect.bottom - containerRect.top - menuRect.height;\n  } else if (align === 'center') {\n    placeToporBottomX = anchorRect.left - containerRect.left - (menuRect.width - anchorRect.width) / 2;\n    placeLeftorRightY = anchorRect.top - containerRect.top - (menuRect.height - anchorRect.height) / 2;\n  } else {\n    placeToporBottomX = anchorRect.left - containerRect.left;\n    placeLeftorRightY = anchorRect.top - containerRect.top;\n  }\n\n  placeToporBottomX += horizontalOffset;\n  placeLeftorRightY += verticalOffset;\n  const options = { ...positionHelpers,\n    anchorRect,\n    placeLeftX,\n    placeRightX,\n    placeLeftorRightY,\n    placeTopY,\n    placeBottomY,\n    placeToporBottomX,\n    arrowRef,\n    arrow,\n    direction,\n    position\n  };\n\n  switch (direction) {\n    case 'left':\n    case 'right':\n      return placeLeftorRight(options);\n\n    case 'top':\n    case 'bottom':\n    default:\n      return placeToporBottom(options);\n  }\n};\n\nconst MenuList = ({\n  ariaLabel,\n  menuClassName,\n  menuStyles,\n  arrowClassName,\n  arrowStyles,\n  anchorPoint,\n  anchorRef,\n  containerRef,\n  externalRef,\n  parentScrollingRef,\n  arrow,\n  align,\n  direction,\n  position,\n  overflow,\n  repositionFlag,\n  captureFocus: _captureFocus = true,\n  state: menuState,\n  endTransition,\n  isDisabled,\n  menuItemFocus,\n  offsetX,\n  offsetY,\n  children,\n  onClose,\n  ...restProps\n}) => {\n  const isOpen = isMenuOpen(menuState);\n  const [menuPosition, setMenuPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [arrowPosition, setArrowPosition] = useState({});\n  const [overflowData, setOverflowData] = useState();\n  const [expandedDirection, setExpandedDirection] = useState(direction);\n  const {\n    transition,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef,\n    rootAnchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  } = useContext(SettingsContext);\n  const menuRef = useRef(null);\n  const arrowRef = useRef(null);\n  const menuItemsCount = useRef(0);\n  const prevOpen = useRef(isOpen);\n  const latestMenuSize = useRef({\n    width: 0,\n    height: 0\n  });\n  const latestHandlePosition = useRef(() => {});\n  const descendOverflowRef = useRef(false);\n  const reposFlag = useContext(MenuListContext).reposSubmenu || repositionFlag;\n  const [reposSubmenu, forceReposSubmenu] = useReducer(c => c + 1, 1);\n  const [{\n    hoverIndex,\n    openSubmenuCount\n  }, dispatch] = useReducer(reducer, {\n    hoverIndex: initialHoverIndex,\n    openSubmenuCount: 0\n  });\n  const openTransition = getTransition(transition, 'open');\n  const closeTransition = getTransition(transition, 'close');\n\n  function reducer({\n    hoverIndex,\n    openSubmenuCount\n  }, action) {\n    return {\n      hoverIndex: hoverIndexReducer(hoverIndex, action),\n      openSubmenuCount: submenuCountReducer(openSubmenuCount, action)\n    };\n  }\n\n  function hoverIndexReducer(state, {\n    type,\n    index\n  }) {\n    switch (type) {\n      case HoverIndexActionTypes.RESET:\n        return initialHoverIndex;\n\n      case HoverIndexActionTypes.SET:\n        return index;\n\n      case HoverIndexActionTypes.UNSET:\n        return state === index ? initialHoverIndex : state;\n\n      case HoverIndexActionTypes.DECREASE:\n        {\n          let i = state;\n          i--;\n          if (i < 0) i = menuItemsCount.current - 1;\n          return i;\n        }\n\n      case HoverIndexActionTypes.INCREASE:\n        {\n          let i = state;\n          i++;\n          if (i >= menuItemsCount.current) i = 0;\n          return i;\n        }\n\n      case HoverIndexActionTypes.FIRST:\n        return menuItemsCount.current > 0 ? 0 : initialHoverIndex;\n\n      case HoverIndexActionTypes.LAST:\n        return menuItemsCount.current > 0 ? menuItemsCount.current - 1 : initialHoverIndex;\n\n      default:\n        return state;\n    }\n  }\n\n  const menuItems = useMemo(() => {\n    const {\n      items,\n      index,\n      descendOverflow\n    } = cloneChildren(children);\n    menuItemsCount.current = index;\n    descendOverflowRef.current = descendOverflow;\n    return items;\n  }, [children]);\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.HOME:\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n        handled = true;\n        break;\n\n      case Keys.END:\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n        handled = true;\n        break;\n\n      case Keys.UP:\n        dispatch({\n          type: HoverIndexActionTypes.DECREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        dispatch({\n          type: HoverIndexActionTypes.INCREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.SPACE:\n        if (e.target && e.target.className.indexOf(menuClass) !== -1) {\n          e.preventDefault();\n        }\n\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleAnimationEnd = () => {\n    if (menuState === 'closing') {\n      setOverflowData();\n    }\n\n    safeCall(endTransition);\n  };\n\n  const handlePosition = useCallback(() => {\n    if (!containerRef.current) {\n      if (!isProd) throw new Error('[React-Menu] Menu cannot be positioned properly as container ref is null. If you initialise isOpen prop to true for ControlledMenu, please see this link for a solution: https://github.com/szhsin/react-menu/issues/2#issuecomment-719166062');\n      return;\n    }\n\n    if (!scrollingRef.current) {\n      scrollingRef.current = boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current);\n    }\n\n    const positionHelpers = getPositionHelpers({\n      menuRef,\n      containerRef,\n      scrollingRef,\n      boundingBoxPadding\n    });\n    const {\n      menuRect\n    } = positionHelpers;\n    let results = {\n      computedDirection: 'bottom'\n    };\n\n    if (anchorPoint) {\n      results = positionContextMenu({\n        positionHelpers,\n        anchorPoint\n      });\n    } else if (anchorRef) {\n      results = positionMenu({\n        arrow,\n        align,\n        direction,\n        offsetX,\n        offsetY,\n        position,\n        anchorRef,\n        arrowRef,\n        positionHelpers\n      });\n    }\n\n    let {\n      arrowX,\n      arrowY,\n      x,\n      y,\n      computedDirection\n    } = results;\n    let menuHeight = menuRect.height;\n\n    if (overflow !== 'visible') {\n      const {\n        getTopOverflow,\n        getBottomOverflow\n      } = positionHelpers;\n      let height, overflowAmt;\n      const prevHeight = latestMenuSize.current.height;\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n        height = menuHeight - bottomOverflow;\n        overflowAmt = bottomOverflow;\n      } else {\n        const topOverflow = getTopOverflow(y);\n\n        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n          height = menuHeight + topOverflow;\n          overflowAmt = 0 - topOverflow;\n          if (height >= 0) y -= topOverflow;\n        }\n      }\n\n      if (height >= 0) {\n        menuHeight = height;\n        setOverflowData({\n          height,\n          overflowAmt\n        });\n      } else {\n        setOverflowData();\n      }\n    }\n\n    if (arrow) setArrowPosition({\n      x: arrowX,\n      y: arrowY\n    });\n    setMenuPosition({\n      x,\n      y\n    });\n    setExpandedDirection(computedDirection);\n    latestMenuSize.current = {\n      width: menuRect.width,\n      height: menuHeight\n    };\n  }, [arrow, align, boundingBoxPadding, direction, offsetX, offsetY, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollingRef]);\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      handlePosition();\n      if (prevOpen.current) forceReposSubmenu();\n    }\n\n    prevOpen.current = isOpen;\n    latestHandlePosition.current = handlePosition;\n  }, [isOpen, handlePosition, reposFlag]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowData && !descendOverflowRef.current) menuRef.current.scrollTop = 0;\n  }, [overflowData]);\n  useEffect(() => {\n    if (!isOpen) return;\n\n    if (!anchorScrollingRef.current && rootAnchorRef && rootAnchorRef.current.tagName) {\n      anchorScrollingRef.current = getScrollAncestor(rootAnchorRef.current);\n    }\n\n    const scrollCurrent = scrollingRef.current;\n    const menuScroll = scrollCurrent && scrollCurrent.addEventListener ? scrollCurrent : window;\n    const anchorScroll = anchorScrollingRef.current || menuScroll;\n    let scroll = viewScroll;\n    if (anchorScroll !== menuScroll && scroll === 'initial') scroll = 'auto';\n    if (scroll === 'initial') return;\n    if (scroll === 'auto' && overflow !== 'visible') scroll = 'close';\n\n    const handleScroll = () => {\n      if (scroll === 'auto') {\n        batchedUpdates(handlePosition);\n      } else {\n        safeCall(onClose, {\n          reason: CloseReason.SCROLL\n        });\n      }\n    };\n\n    const scrollObservers = anchorScroll !== menuScroll && viewScroll !== 'initial' ? [anchorScroll, menuScroll] : [anchorScroll];\n    scrollObservers.forEach(o => o.addEventListener('scroll', handleScroll));\n    return () => scrollObservers.forEach(o => o.removeEventListener('scroll', handleScroll));\n  }, [rootAnchorRef, anchorScrollingRef, scrollingRef, isOpen, overflow, onClose, viewScroll, handlePosition]);\n  const hasOverflow = !!overflowData && overflowData.overflowAmt > 0;\n  useEffect(() => {\n    if (hasOverflow || !isOpen || !parentScrollingRef) return;\n\n    const handleScroll = () => batchedUpdates(handlePosition);\n\n    const parentScroll = parentScrollingRef.current;\n    parentScroll.addEventListener('scroll', handleScroll);\n    return () => parentScroll.removeEventListener('scroll', handleScroll);\n  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);\n  useEffect(() => {\n    if (typeof ResizeObserver !== 'function' || reposition === 'initial') return;\n    const resizeObserver = new ResizeObserver(([entry]) => {\n      const {\n        borderBoxSize,\n        target\n      } = entry;\n      let width, height;\n\n      if (borderBoxSize) {\n        const {\n          inlineSize,\n          blockSize\n        } = borderBoxSize[0] || borderBoxSize;\n        width = inlineSize;\n        height = blockSize;\n      } else {\n        const borderRect = target.getBoundingClientRect();\n        width = borderRect.width;\n        height = borderRect.height;\n      }\n\n      if (width === 0 || height === 0) return;\n      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1)) return;\n      batchedUpdates(() => {\n        latestHandlePosition.current();\n        forceReposSubmenu();\n      });\n    });\n    const observeTarget = menuRef.current;\n    resizeObserver.observe(observeTarget, {\n      box: 'border-box'\n    });\n    return () => resizeObserver.unobserve(observeTarget);\n  }, [reposition]);\n  useEffect(() => {\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.RESET\n      });\n      if (!closeTransition) setOverflowData();\n      return;\n    }\n\n    const id = setTimeout(() => {\n      if (!menuRef.current) return;\n      const {\n        position,\n        alwaysUpdate\n      } = menuItemFocus || {};\n      if (!alwaysUpdate && menuRef.current.contains(document.activeElement)) return;\n      if (_captureFocus) menuRef.current.focus();\n\n      if (position === FocusPositions.FIRST) {\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n      } else if (position === FocusPositions.LAST) {\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n      } else if (position >= 0 && position < menuItemsCount.current) {\n        dispatch({\n          type: HoverIndexActionTypes.SET,\n          index: position\n        });\n      }\n    }, openTransition ? 170 : 100);\n    return () => clearTimeout(id);\n  }, [openTransition, closeTransition, _captureFocus, isOpen, menuItemFocus]);\n  const isSubmenuOpen = openSubmenuCount > 0;\n  const itemContext = useMemo(() => ({\n    parentMenuRef: menuRef,\n    parentOverflow: overflow,\n    isParentOpen: isOpen,\n    isSubmenuOpen,\n    dispatch\n  }), [isOpen, isSubmenuOpen, overflow]);\n  let maxHeight, overflowAmt;\n\n  if (overflowData) {\n    descendOverflowRef.current ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;\n  }\n\n  const listContext = useMemo(() => ({\n    reposSubmenu,\n    overflow,\n    overflowAmt\n  }), [reposSubmenu, overflow, overflowAmt]);\n  const overflowStyles = maxHeight >= 0 ? {\n    maxHeight,\n    overflow\n  } : undefined;\n  const modifiers = useMemo(() => ({\n    state: menuState,\n    dir: expandedDirection\n  }), [menuState, expandedDirection]);\n  const arrowModifiers = useMemo(() => Object.freeze({\n    dir: expandedDirection\n  }), [expandedDirection]);\n\n  const _arrowClass = useBEM({\n    block: menuClass,\n    element: menuArrowClass,\n    modifiers: arrowModifiers,\n    className: arrowClassName\n  });\n\n  const _arrowStyles = useFlatStyles(arrowStyles, arrowModifiers);\n\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onAnimationEnd: handleAnimationEnd\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"menu\",\n    tabIndex: \"-1\",\n    \"aria-disabled\": isDisabled || undefined,\n    \"aria-label\": ariaLabel\n  }, restProps, handlers, {\n    ref: useCombinedRef(externalRef, menuRef),\n    className: useBEM({\n      block: menuClass,\n      modifiers,\n      className: menuClassName\n    }),\n    style: { ...useFlatStyles(menuStyles, modifiers),\n      ...overflowStyles,\n      left: `${menuPosition.x}px`,\n      top: `${menuPosition.y}px`\n    }\n  }), arrow && /*#__PURE__*/React.createElement(\"div\", {\n    className: _arrowClass,\n    style: { ..._arrowStyles,\n      left: arrowPosition.x && `${arrowPosition.x}px`,\n      top: arrowPosition.y && `${arrowPosition.y}px`\n    },\n    ref: arrowRef\n  }), /*#__PURE__*/React.createElement(MenuListContext.Provider, {\n    value: listContext\n  }, /*#__PURE__*/React.createElement(MenuListItemContext.Provider, {\n    value: itemContext\n  }, /*#__PURE__*/React.createElement(HoverIndexContext.Provider, {\n    value: hoverIndex\n  }, menuItems))));\n};\n\nfunction submenuCountReducer(state, {\n  type\n}) {\n  switch (type) {\n    case SubmenuActionTypes.OPEN:\n      return state + 1;\n\n    case SubmenuActionTypes.CLOSE:\n      return Math.max(state - 1, 0);\n\n    default:\n      return state;\n  }\n}\n\nconst ControlledMenu = /*#__PURE__*/forwardRef(function ControlledMenu({\n  'aria-label': ariaLabel,\n  className,\n  containerProps,\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout,\n  boundingBoxRef,\n  boundingBoxPadding,\n  reposition,\n  submenuOpenDelay,\n  submenuCloseDelay,\n  skipOpen,\n  viewScroll,\n  portal,\n  theming,\n  onItemClick,\n  onClose,\n  ...restProps\n}, externalRef) {\n  const containerRef = useRef(null);\n  const scrollingRef = useRef(null);\n  const anchorScrollingRef = useRef(null);\n  const {\n    anchorRef,\n    state\n  } = restProps;\n  const settings = useMemo(() => ({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef: containerRef,\n    rootAnchorRef: anchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  }), [initialMounted, unmountOnClose, transition, transitionTimeout, anchorRef, boundingBoxRef, boundingBoxPadding, reposition, viewScroll]);\n  const itemSettings = useMemo(() => ({\n    submenuOpenDelay,\n    submenuCloseDelay\n  }), [submenuOpenDelay, submenuCloseDelay]);\n  const eventHandlers = useMemo(() => ({\n    handleClick(event, isCheckorRadio) {\n      if (!event.stopPropagation) safeCall(onItemClick, event);\n      let keepOpen = event.keepOpen;\n\n      if (keepOpen === undefined) {\n        keepOpen = isCheckorRadio && event.key === Keys.SPACE;\n      }\n\n      if (!keepOpen) {\n        safeCall(onClose, {\n          value: event.value,\n          key: event.key,\n          reason: CloseReason.CLICK\n        });\n      }\n    },\n\n    handleClose(key) {\n      safeCall(onClose, {\n        key,\n        reason: CloseReason.CLICK\n      });\n    }\n\n  }), [onItemClick, onClose]);\n\n  const handleKeyDown = ({\n    key\n  }) => {\n    switch (key) {\n      case Keys.ESC:\n        safeCall(onClose, {\n          key,\n          reason: CloseReason.CANCEL\n        });\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    if (isMenuOpen(state) && !e.currentTarget.contains(e.relatedTarget || document.activeElement)) {\n      safeCall(onClose, {\n        reason: CloseReason.BLUR\n      });\n\n      if (skipOpen) {\n        skipOpen.current = true;\n        setTimeout(() => skipOpen.current = false, 300);\n      }\n    }\n  };\n\n  const itemTransition = getTransition(transition, 'item');\n  const modifiers = useMemo(() => ({\n    theme: theming,\n    itemTransition\n  }), [theming, itemTransition]);\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur\n  }, containerProps);\n  const menuList = /*#__PURE__*/React.createElement(\"div\", Object.assign({}, containerProps, handlers, {\n    className: useBEM({\n      block: menuContainerClass,\n      modifiers,\n      className\n    }),\n    ref: containerRef\n  }), state && /*#__PURE__*/React.createElement(SettingsContext.Provider, {\n    value: settings\n  }, /*#__PURE__*/React.createElement(ItemSettingsContext.Provider, {\n    value: itemSettings\n  }, /*#__PURE__*/React.createElement(EventHandlersContext.Provider, {\n    value: eventHandlers\n  }, /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, {\n    ariaLabel: ariaLabel || 'Menu',\n    externalRef: externalRef,\n    containerRef: containerRef,\n    onClose: onClose\n  }))))));\n\n  if (portal) {\n    return /*#__PURE__*/ReactDOM.createPortal(menuList, document.body);\n  } else {\n    return menuList;\n  }\n});\nControlledMenu.propTypes = { ...rootMenuPropTypes,\n  state: PropTypes.oneOf(values(MenuStateMap)),\n  anchorPoint: PropTypes.exact({\n    x: PropTypes.number,\n    y: PropTypes.number\n  }),\n  anchorRef: PropTypes.object,\n  skipOpen: PropTypes.object,\n  captureFocus: PropTypes.bool,\n  menuItemFocus: PropTypes.exact({\n    position: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    alwaysUpdate: PropTypes.bool\n  }),\n  onClose: PropTypes.func\n};\nControlledMenu.defaultProps = { ...rootMenuDefaultProps,\n  menuItemFocus: {}\n};\n\nconst Menu = /*#__PURE__*/forwardRef(function Menu({\n  'aria-label': ariaLabel,\n  captureFocus: _,\n  menuButton,\n  instanceRef,\n  onMenuChange,\n  ...restProps\n}, externalRef) {\n  const {\n    openMenu,\n    toggleMenu,\n    ...stateProps\n  } = useMenuStateAndFocus(restProps);\n  const isOpen = isMenuOpen(stateProps.state);\n  const skipOpen = useRef(false);\n  const buttonRef = useRef(null);\n  const handleClose = useCallback(e => {\n    toggleMenu(false);\n    if (e.key) buttonRef.current.focus();\n  }, [toggleMenu]);\n\n  const handleClick = e => {\n    if (skipOpen.current) return;\n    openMenu(e.detail === 0 ? FocusPositions.FIRST : undefined);\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.UP:\n        openMenu(FocusPositions.LAST);\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        openMenu(FocusPositions.FIRST);\n        handled = true;\n        break;\n    }\n\n    if (handled) e.preventDefault();\n  };\n\n  const button = safeCall(menuButton, {\n    open: isOpen\n  });\n  if (!button) throw new Error('Menu requires a menuButton prop.');\n  const buttonProps = {\n    ref: useCombinedRef(button.ref, buttonRef),\n    ...attachHandlerProps({\n      onClick: handleClick,\n      onKeyDown: handleKeyDown\n    }, button.props)\n  };\n\n  if (getName(button.type) === 'MenuButton') {\n    buttonProps.isOpen = isOpen;\n  }\n\n  const renderButton = /*#__PURE__*/React.cloneElement(button, buttonProps);\n  useMenuChange(onMenuChange, isOpen);\n  useImperativeHandle(instanceRef, () => ({\n    openMenu,\n    closeMenu: () => toggleMenu(false)\n  }));\n  const menuProps = { ...restProps,\n    ...stateProps,\n    'aria-label': ariaLabel || (typeof button.props.children === 'string' ? button.props.children : 'Menu'),\n    anchorRef: buttonRef,\n    ref: externalRef,\n    onClose: handleClose,\n    skipOpen\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, renderButton, /*#__PURE__*/React.createElement(ControlledMenu, menuProps));\n});\nMenu.propTypes = { ...rootMenuPropTypes,\n  ...uncontrolledMenuPropTypes,\n  menuButton: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired\n};\nMenu.defaultProps = rootMenuDefaultProps;\n\nconst SubMenu = withHovering( /*#__PURE__*/memo(function SubMenu({\n  'aria-label': ariaLabel,\n  className,\n  disabled,\n  label,\n  index,\n  onMenuChange,\n  isHovering,\n  instanceRef,\n  captureFocus: _1,\n  repositionFlag: _2,\n  itemProps = {},\n  ...restProps\n}) {\n  const isDisabled = !!disabled;\n  validateIndex(index, isDisabled, label);\n  const {\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    rootMenuRef\n  } = useContext(SettingsContext);\n  const {\n    submenuOpenDelay,\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    parentMenuRef,\n    parentOverflow,\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const isPortal = parentOverflow !== 'visible';\n  const {\n    openMenu,\n    toggleMenu,\n    state,\n    ...otherStateProps\n  } = useMenuStateAndFocus({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout\n  });\n  const isOpen = isMenuOpen(state);\n  const {\n    isActive,\n    onKeyUp,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled, Keys.RIGHT);\n  const containerRef = useRef(null);\n  const itemRef = useRef(null);\n  const timeoutId = useRef();\n\n  const setHover = () => !isHovering && dispatch({\n    type: HoverIndexActionTypes.SET,\n    index\n  });\n\n  const delayOpen = delay => {\n    dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n    timeoutId.current = setTimeout(openMenu, Math.max(delay, 0));\n  };\n\n  const handleMouseEnter = () => {\n    if (isDisabled || isOpen) return;\n\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(() => delayOpen(submenuOpenDelay - submenuCloseDelay), submenuCloseDelay);\n    } else {\n      delayOpen(submenuOpenDelay);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    clearTimeout(timeoutId.current);\n\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const handleClick = () => {\n    if (isDisabled) return;\n    clearTimeout(timeoutId.current);\n    openMenu();\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.LEFT:\n        if (isOpen) {\n          itemRef.current.focus();\n          toggleMenu(false);\n          handled = true;\n        }\n\n        break;\n\n      case Keys.RIGHT:\n        if (!isOpen) handled = true;\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.ENTER:\n      case Keys.SPACE:\n      case Keys.RIGHT:\n        openMenu(FocusPositions.FIRST);\n        break;\n    }\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      itemRef.current.focus();\n    } else {\n      toggleMenu(false);\n    }\n  }, [isHovering, isParentOpen, toggleMenu]);\n  useEffect(() => {\n    dispatch({\n      type: isOpen ? SubmenuActionTypes.OPEN : SubmenuActionTypes.CLOSE\n    });\n  }, [dispatch, isOpen]);\n  useMenuChange(onMenuChange, isOpen);\n  useImperativeHandle(instanceRef, () => ({\n    openMenu: (...args) => {\n      if (isParentOpen) {\n        setHover();\n        openMenu(...args);\n      }\n    },\n    closeMenu: () => {\n      if (isOpen) {\n        itemRef.current.focus();\n        toggleMenu(false);\n      }\n    }\n  }));\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen,\n    hover: isHovering,\n    active: isActive,\n    disabled: isDisabled\n  }), [isOpen, isHovering, isActive, isDisabled]);\n  const {\n    ref: externaItemlRef,\n    className: itemClassName,\n    styles: itemStyles,\n    ...restItemProps\n  } = itemProps;\n  const itemHandlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onMouseDown: setHover,\n    onClick: handleClick,\n    onKeyUp: handleKeyUp\n  }, restItemProps);\n\n  const getMenuList = () => {\n    const menuList = /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, otherStateProps, {\n      state: state,\n      ariaLabel: ariaLabel || (typeof label === 'string' ? label : 'Submenu'),\n      anchorRef: itemRef,\n      containerRef: isPortal ? rootMenuRef : containerRef,\n      parentScrollingRef: isPortal && parentMenuRef,\n      isDisabled: isDisabled\n    }));\n    return isPortal ? /*#__PURE__*/createPortal(menuList, rootMenuRef.current) : menuList;\n  };\n\n  return /*#__PURE__*/React.createElement(\"li\", {\n    className: useBEM({\n      block: menuClass,\n      element: subMenuClass,\n      className\n    }),\n    role: \"presentation\",\n    ref: containerRef,\n    onKeyDown: handleKeyDown\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    role: \"menuitem\",\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": isDisabled || undefined,\n    tabIndex: isHovering && !isOpen ? 0 : -1\n  }, restItemProps, itemHandlers, {\n    ref: useCombinedRef(externaItemlRef, itemRef),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className: itemClassName\n    }),\n    style: useFlatStyles(itemStyles, modifiers)\n  }), useMemo(() => safeCall(label, modifiers), [label, modifiers])), state && getMenuList());\n}), 'SubMenu');\nSubMenu.propTypes = { ...menuPropTypes,\n  ...uncontrolledMenuPropTypes,\n  disabled: PropTypes.bool,\n  label: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  itemProps: PropTypes.shape({ ...stylePropTypes()\n  })\n};\nSubMenu.defaultProps = { ...menuDefaultProps,\n  direction: 'right'\n};\n\nconst MenuItem = withHovering( /*#__PURE__*/memo(function MenuItem({\n  className,\n  styles,\n  value,\n  href,\n  type,\n  checked,\n  disabled,\n  index,\n  children,\n  onClick,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = !!disabled;\n  validateIndex(index, isDisabled, children);\n  const ref = useRef();\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const eventHandlers = useContext(EventHandlersContext);\n  const radioGroup = useContext(RadioGroupContext);\n  const {\n    isActive,\n    onKeyUp,\n    onBlur: activeStateBlur,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled);\n  const isRadio = type === 'radio';\n  const isCheckBox = type === 'checkbox';\n  const isAnchor = !!href && !isDisabled && !isRadio && !isCheckBox;\n  const isChecked = isRadio ? radioGroup.value === value : isCheckBox ? !!checked : false;\n\n  const handleClick = e => {\n    if (isDisabled) return;\n    const event = {\n      value,\n      syntheticEvent: e\n    };\n    if (e.key !== undefined) event.key = e.key;\n    if (isCheckBox) event.checked = !isChecked;\n\n    if (isRadio) {\n      event.name = radioGroup.name;\n      safeCall(radioGroup.onRadioChange, event);\n    }\n\n    if (!event.stopPropagation) safeCall(onClick, event);\n    eventHandlers.handleClick(event, isCheckBox || isRadio);\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.ENTER:\n      case Keys.SPACE:\n        if (isAnchor) {\n          ref.current.click();\n        } else {\n          handleClick(e);\n        }\n\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    activeStateBlur(e);\n    onBlur(e);\n  };\n\n  const modifiers = useMemo(() => Object.freeze({\n    type,\n    disabled: isDisabled,\n    hover: isHovering,\n    active: isActive,\n    checked: isChecked,\n    anchor: isAnchor\n  }), [type, isDisabled, isHovering, isActive, isChecked, isAnchor]);\n  const handlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown: setHover,\n    onKeyUp: handleKeyUp,\n    onBlur: handleBlur,\n    onClick: handleClick\n  }, restProps);\n  const menuItemProps = {\n    role: isRadio ? 'menuitemradio' : isCheckBox ? 'menuitemcheckbox' : 'menuitem',\n    'aria-checked': isRadio || isCheckBox ? isChecked : undefined,\n    'aria-disabled': isDisabled || undefined,\n    tabIndex: isHovering ? 0 : -1,\n    ...restProps,\n    ...handlers,\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  };\n  const renderChildren = useMemo(() => safeCall(children, modifiers), [children, modifiers]);\n\n  if (isAnchor) {\n    return /*#__PURE__*/React.createElement(\"li\", {\n      role: \"presentation\"\n    }, /*#__PURE__*/React.createElement(\"a\", Object.assign({}, menuItemProps, {\n      href: href\n    }), renderChildren));\n  } else {\n    return /*#__PURE__*/React.createElement(\"li\", menuItemProps, renderChildren);\n  }\n}), 'MenuItem');\nMenuItem.propTypes = { ...stylePropTypes(),\n  value: PropTypes.any,\n  href: PropTypes.string,\n  type: PropTypes.oneOf(['checkbox', 'radio']),\n  checked: PropTypes.bool,\n  disabled: PropTypes.bool,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  onClick: PropTypes.func\n};\n\nconst FocusableItem = withHovering( /*#__PURE__*/memo(function FocusableItem({\n  className,\n  styles,\n  disabled,\n  index,\n  children,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = !!disabled;\n  validateIndex(index, isDisabled, children);\n  const ref = useRef(null);\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const {\n    handleClose\n  } = useContext(EventHandlersContext);\n  const modifiers = useMemo(() => Object.freeze({\n    disabled: isDisabled,\n    hover: isHovering,\n    focusable: true\n  }), [isDisabled, isHovering]);\n  const renderChildren = useMemo(() => safeCall(children, { ...modifiers,\n    ref,\n    closeMenu: handleClose\n  }), [children, modifiers, handleClose]);\n  const handlers = attachHandlerProps({\n    onMouseEnter,\n    onMouseLeave: e => onMouseLeave(e, true),\n    onFocus: setHover,\n    onBlur\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    \"aria-disabled\": isDisabled || undefined,\n    role: \"menuitem\",\n    tabIndex: \"-1\"\n  }, restProps, handlers, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), renderChildren);\n}), 'FocusableItem');\nFocusableItem.propTypes = { ...stylePropTypes(),\n  disabled: PropTypes.bool,\n  children: PropTypes.func\n};\n\nconst MenuDivider = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuDivider({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"separator\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuDividerClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n}));\nMenuDivider.propTypes = { ...stylePropTypes()\n};\n\nconst MenuHeader = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuHeader({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"presentation\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuHeaderClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n}));\nMenuHeader.propTypes = { ...stylePropTypes()\n};\n\nconst MenuGroup = defineName( /*#__PURE__*/forwardRef(function MenuGroup({\n  className,\n  styles,\n  takeOverflow,\n  ...restProps\n}, externalRef) {\n  const ref = useRef(null);\n  const [overflowStyles, setOverflowStyles] = useState();\n  const {\n    overflow,\n    overflowAmt\n  } = useContext(MenuListContext);\n  useIsomorphicLayoutEffect(() => {\n    let maxHeight;\n\n    if (takeOverflow && overflowAmt >= 0) {\n      maxHeight = ref.current.getBoundingClientRect().height - overflowAmt;\n      if (maxHeight < 0) maxHeight = 0;\n    }\n\n    setOverflowStyles(maxHeight >= 0 ? {\n      maxHeight,\n      overflow\n    } : undefined);\n  }, [takeOverflow, overflow, overflowAmt]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowStyles) ref.current.scrollTop = 0;\n  }, [overflowStyles]);\n  return /*#__PURE__*/React.createElement(\"div\", Object.assign({}, restProps, {\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuGroupClass,\n      className\n    }),\n    style: { ...useFlatStyles(styles),\n      ...overflowStyles\n    }\n  }));\n}), 'MenuGroup');\nMenuGroup.propTypes = { ...stylePropTypes(),\n  takeOverflow: PropTypes.bool\n};\n\nconst MenuRadioGroup = defineName( /*#__PURE__*/forwardRef(function MenuRadioGroup({\n  'aria-label': ariaLabel,\n  className,\n  styles,\n  name,\n  value,\n  onRadioChange,\n  ...restProps\n}, externalRef) {\n  const contextValue = useMemo(() => ({\n    name,\n    value,\n    onRadioChange\n  }), [name, value, onRadioChange]);\n  return /*#__PURE__*/React.createElement(RadioGroupContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    role: \"presentation\"\n  }, /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"group\",\n    \"aria-label\": ariaLabel || name || 'Radio group'\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: radioGroupClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }))));\n}), 'MenuRadioGroup');\nMenuRadioGroup.propTypes = { ...stylePropTypes(),\n  name: PropTypes.string,\n  value: PropTypes.any,\n  onRadioChange: PropTypes.func\n};\n\nexport { ControlledMenu, FocusableItem, Menu, MenuButton, MenuDivider, MenuGroup, MenuHeader, MenuItem, MenuRadioGroup, SubMenu, applyHOC, applyStatics, useMenuState };\n"]},"metadata":{},"sourceType":"module"}